(* mips - generated by L<3> - Fri Apr 04 14:51:10 2014 *)

structure mips :> mips =
struct

structure Map = MutableMap

(* -------------------------------------------------------------------------
   Type declarations
   ------------------------------------------------------------------------- *)

type StatusRegister =
  { BEV: bool, CU0: bool, ERL: bool, EXL: bool, FR: bool, IE: bool,
    IM0: bool, IM1: bool, KSU: BitsN.nbit, KX: bool, RE: bool, SX: bool,
    UX: bool, statusregister'rst: BitsN.nbit }

type ConfigRegister = { BE: bool, configregister'rst: BitsN.nbit }

type CauseRegister =
  { BD: bool, ExcCode: BitsN.nbit, causeregister'rst: BitsN.nbit }

type CP0 =
  { BadVAddr: BitsN.nbit, Cause: CauseRegister, Compare: BitsN.nbit,
    Config: ConfigRegister, Count: BitsN.nbit, Debug: BitsN.nbit,
    EPC: BitsN.nbit, ErrCtl: BitsN.nbit, ErrorEPC: BitsN.nbit,
    LLAddr: BitsN.nbit, PRId: BitsN.nbit, Status: StatusRegister }

datatype ExceptionType = AdEL | AdES | Sys | Bp | RI | CpU | Ov | Tr

datatype IorD = INSTRUCTION | DATA

datatype LorS = LOAD | STORE

datatype event =
    w_c0 of BitsN.nbit * BitsN.nbit
  | w_gpr of BitsN.nbit * BitsN.nbit
  | w_hi of BitsN.nbit
  | w_lo of BitsN.nbit
  | w_mem of BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))

datatype Branch =
    BEQ of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | BEQL of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | BGEZ of BitsN.nbit * BitsN.nbit
  | BGEZAL of BitsN.nbit * BitsN.nbit
  | BGEZALL of BitsN.nbit * BitsN.nbit
  | BGEZL of BitsN.nbit * BitsN.nbit
  | BGTZ of BitsN.nbit * BitsN.nbit
  | BGTZL of BitsN.nbit * BitsN.nbit
  | BLEZ of BitsN.nbit * BitsN.nbit
  | BLEZL of BitsN.nbit * BitsN.nbit
  | BLTZ of BitsN.nbit * BitsN.nbit
  | BLTZAL of BitsN.nbit * BitsN.nbit
  | BLTZALL of BitsN.nbit * BitsN.nbit
  | BLTZL of BitsN.nbit * BitsN.nbit
  | BNE of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | BNEL of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | J of BitsN.nbit
  | JAL of BitsN.nbit
  | JALR of BitsN.nbit * BitsN.nbit
  | JR of BitsN.nbit

datatype CP =
    DMFC0 of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | DMTC0 of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | MFC0 of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | MTC0 of BitsN.nbit * (BitsN.nbit * BitsN.nbit)

datatype Store =
    SB of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SC of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SCD of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SD of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SDL of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SDR of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SH of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SW of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SWL of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SWR of BitsN.nbit * (BitsN.nbit * BitsN.nbit)

datatype Load =
    LB of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | LBU of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | LD of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | LDL of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | LDR of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | LH of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | LHU of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | LL of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | LLD of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | LW of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | LWL of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | LWR of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | LWU of BitsN.nbit * (BitsN.nbit * BitsN.nbit)

datatype Trap =
    TEQ of BitsN.nbit * BitsN.nbit
  | TEQI of BitsN.nbit * BitsN.nbit
  | TGE of BitsN.nbit * BitsN.nbit
  | TGEI of BitsN.nbit * BitsN.nbit
  | TGEIU of BitsN.nbit * BitsN.nbit
  | TGEU of BitsN.nbit * BitsN.nbit
  | TLT of BitsN.nbit * BitsN.nbit
  | TLTI of BitsN.nbit * BitsN.nbit
  | TLTIU of BitsN.nbit * BitsN.nbit
  | TLTU of BitsN.nbit * BitsN.nbit
  | TNE of BitsN.nbit * BitsN.nbit
  | TNEI of BitsN.nbit * BitsN.nbit

datatype Shift =
    DSLL of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | DSLL32 of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | DSLLV of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | DSRA of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | DSRA32 of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | DSRAV of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | DSRL of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | DSRL32 of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | DSRLV of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SLL of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SLLV of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SRA of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SRAV of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SRL of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SRLV of BitsN.nbit * (BitsN.nbit * BitsN.nbit)

datatype MultDiv =
    DDIV of BitsN.nbit * BitsN.nbit
  | DDIVU of BitsN.nbit * BitsN.nbit
  | DIV of BitsN.nbit * BitsN.nbit
  | DIVU of BitsN.nbit * BitsN.nbit
  | DMULT of BitsN.nbit * BitsN.nbit
  | DMULTU of BitsN.nbit * BitsN.nbit
  | MADD of BitsN.nbit * BitsN.nbit
  | MADDU of BitsN.nbit * BitsN.nbit
  | MFHI of BitsN.nbit
  | MFLO of BitsN.nbit
  | MSUB of BitsN.nbit * BitsN.nbit
  | MSUBU of BitsN.nbit * BitsN.nbit
  | MTHI of BitsN.nbit
  | MTLO of BitsN.nbit
  | MUL of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | MULT of BitsN.nbit * BitsN.nbit
  | MULTU of BitsN.nbit * BitsN.nbit

datatype ArithR =
    ADD of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | ADDU of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | AND of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | DADD of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | DADDU of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | DSUB of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | DSUBU of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | MOVN of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | MOVZ of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | NOR of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | OR of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SLT of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SLTU of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SUB of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SUBU of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | XOR of BitsN.nbit * (BitsN.nbit * BitsN.nbit)

datatype ArithI =
    ADDI of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | ADDIU of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | ANDI of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | DADDI of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | DADDIU of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | LUI of BitsN.nbit * BitsN.nbit
  | ORI of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SLTI of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SLTIU of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | XORI of BitsN.nbit * (BitsN.nbit * BitsN.nbit)

datatype instruction =
    ArithI of ArithI
  | ArithR of ArithR
  | BREAK
  | Branch of Branch
  | CP of CP
  | ERET
  | Load of Load
  | MultDiv of MultDiv
  | ReservedInstruction
  | SYNC of BitsN.nbit
  | SYSCALL
  | Shift of Shift
  | Store of Store
  | Trap of Trap

(* -------------------------------------------------------------------------
   Casting maps (for enumerated types)
   ------------------------------------------------------------------------- *)

structure Cast =
struct
fun natToExceptionType x =
  case Nat.toInt x of
     0 => AdEL
   | 1 => AdES
   | 2 => Sys
   | 3 => Bp
   | 4 => RI
   | 5 => CpU
   | 6 => Ov
   | 7 => Tr
   | _ => raise Fail "natToExceptionType"

fun natToIorD x =
  case Nat.toInt x of
     0 => INSTRUCTION | 1 => DATA | _ => raise Fail "natToIorD"

fun natToLorS x =
  case Nat.toInt x of
     0 => LOAD | 1 => STORE | _ => raise Fail "natToLorS"

fun ExceptionTypeToNat x =
  case x of
     AdEL => 0
   | AdES => 1
   | Sys => 2
   | Bp => 3
   | RI => 4
   | CpU => 5
   | Ov => 6
   | Tr => 7

fun IorDToNat x = case x of   INSTRUCTION => 0 | DATA => 1

fun LorSToNat x =
  case x of
     LOAD => 0 | STORE => 1

fun ExceptionTypeToString x =
  case x of
     AdEL => "AdEL"
   | AdES => "AdES"
   | Sys => "Sys"
   | Bp => "Bp"
   | RI => "RI"
   | CpU => "CpU"
   | Ov => "Ov"
   | Tr => "Tr"

fun IorDToString x =
  case x of
     INSTRUCTION => "INSTRUCTION" | DATA => "DATA"

fun LorSToString x =
  case x of
     LOAD => "LOAD" | STORE => "STORE"

fun stringToExceptionType x =
  case x of
     "AdEL" => AdEL
   | "AdES" => AdES
   | "Sys" => Sys
   | "Bp" => Bp
   | "RI" => RI
   | "CpU" => CpU
   | "Ov" => Ov
   | "Tr" => Tr
   | _ => raise Fail "stringToExceptionType"

fun stringToIorD x =
  case x of
     "INSTRUCTION" => INSTRUCTION
   | "DATA" => DATA
   | _ => raise Fail "stringToIorD"

fun stringToLorS x =
  case x of
     "LOAD" => LOAD | "STORE" => STORE | _ => raise Fail "stringToLorS"
end

(* -------------------------------------------------------------------------
   Record update functions
   ------------------------------------------------------------------------- *)

fun StatusRegister_BEV_rupd ({BEV, CU0, ERL, EXL, FR, IE, IM0, IM1, KSU,
   KX, RE, SX, UX, statusregister'rst}: StatusRegister, x') =
  {BEV = x', CU0 = CU0, ERL = ERL, EXL = EXL, FR = FR, IE = IE, IM0 = IM0,
   IM1 = IM1, KSU = KSU, KX = KX, RE = RE, SX = SX, UX = UX,
   statusregister'rst = statusregister'rst}: StatusRegister

fun StatusRegister_CU0_rupd ({BEV, CU0, ERL, EXL, FR, IE, IM0, IM1, KSU,
   KX, RE, SX, UX, statusregister'rst}: StatusRegister, x') =
  {BEV = BEV, CU0 = x', ERL = ERL, EXL = EXL, FR = FR, IE = IE, IM0 = IM0,
   IM1 = IM1, KSU = KSU, KX = KX, RE = RE, SX = SX, UX = UX,
   statusregister'rst = statusregister'rst}: StatusRegister

fun StatusRegister_ERL_rupd ({BEV, CU0, ERL, EXL, FR, IE, IM0, IM1, KSU,
   KX, RE, SX, UX, statusregister'rst}: StatusRegister, x') =
  {BEV = BEV, CU0 = CU0, ERL = x', EXL = EXL, FR = FR, IE = IE, IM0 = IM0,
   IM1 = IM1, KSU = KSU, KX = KX, RE = RE, SX = SX, UX = UX,
   statusregister'rst = statusregister'rst}: StatusRegister

fun StatusRegister_EXL_rupd ({BEV, CU0, ERL, EXL, FR, IE, IM0, IM1, KSU,
   KX, RE, SX, UX, statusregister'rst}: StatusRegister, x') =
  {BEV = BEV, CU0 = CU0, ERL = ERL, EXL = x', FR = FR, IE = IE, IM0 = IM0,
   IM1 = IM1, KSU = KSU, KX = KX, RE = RE, SX = SX, UX = UX,
   statusregister'rst = statusregister'rst}: StatusRegister

fun StatusRegister_FR_rupd ({BEV, CU0, ERL, EXL, FR, IE, IM0, IM1, KSU,
   KX, RE, SX, UX, statusregister'rst}: StatusRegister, x') =
  {BEV = BEV, CU0 = CU0, ERL = ERL, EXL = EXL, FR = x', IE = IE,
   IM0 = IM0, IM1 = IM1, KSU = KSU, KX = KX, RE = RE, SX = SX, UX = UX,
   statusregister'rst = statusregister'rst}: StatusRegister

fun StatusRegister_IE_rupd ({BEV, CU0, ERL, EXL, FR, IE, IM0, IM1, KSU,
   KX, RE, SX, UX, statusregister'rst}: StatusRegister, x') =
  {BEV = BEV, CU0 = CU0, ERL = ERL, EXL = EXL, FR = FR, IE = x',
   IM0 = IM0, IM1 = IM1, KSU = KSU, KX = KX, RE = RE, SX = SX, UX = UX,
   statusregister'rst = statusregister'rst}: StatusRegister

fun StatusRegister_IM0_rupd ({BEV, CU0, ERL, EXL, FR, IE, IM0, IM1, KSU,
   KX, RE, SX, UX, statusregister'rst}: StatusRegister, x') =
  {BEV = BEV, CU0 = CU0, ERL = ERL, EXL = EXL, FR = FR, IE = IE, IM0 = x',
   IM1 = IM1, KSU = KSU, KX = KX, RE = RE, SX = SX, UX = UX,
   statusregister'rst = statusregister'rst}: StatusRegister

fun StatusRegister_IM1_rupd ({BEV, CU0, ERL, EXL, FR, IE, IM0, IM1, KSU,
   KX, RE, SX, UX, statusregister'rst}: StatusRegister, x') =
  {BEV = BEV, CU0 = CU0, ERL = ERL, EXL = EXL, FR = FR, IE = IE,
   IM0 = IM0, IM1 = x', KSU = KSU, KX = KX, RE = RE, SX = SX, UX = UX,
   statusregister'rst = statusregister'rst}: StatusRegister

fun StatusRegister_KSU_rupd ({BEV, CU0, ERL, EXL, FR, IE, IM0, IM1, KSU,
   KX, RE, SX, UX, statusregister'rst}: StatusRegister, x') =
  {BEV = BEV, CU0 = CU0, ERL = ERL, EXL = EXL, FR = FR, IE = IE,
   IM0 = IM0, IM1 = IM1, KSU = x', KX = KX, RE = RE, SX = SX, UX = UX,
   statusregister'rst = statusregister'rst}: StatusRegister

fun StatusRegister_KX_rupd ({BEV, CU0, ERL, EXL, FR, IE, IM0, IM1, KSU,
   KX, RE, SX, UX, statusregister'rst}: StatusRegister, x') =
  {BEV = BEV, CU0 = CU0, ERL = ERL, EXL = EXL, FR = FR, IE = IE,
   IM0 = IM0, IM1 = IM1, KSU = KSU, KX = x', RE = RE, SX = SX, UX = UX,
   statusregister'rst = statusregister'rst}: StatusRegister

fun StatusRegister_RE_rupd ({BEV, CU0, ERL, EXL, FR, IE, IM0, IM1, KSU,
   KX, RE, SX, UX, statusregister'rst}: StatusRegister, x') =
  {BEV = BEV, CU0 = CU0, ERL = ERL, EXL = EXL, FR = FR, IE = IE,
   IM0 = IM0, IM1 = IM1, KSU = KSU, KX = KX, RE = x', SX = SX, UX = UX,
   statusregister'rst = statusregister'rst}: StatusRegister

fun StatusRegister_SX_rupd ({BEV, CU0, ERL, EXL, FR, IE, IM0, IM1, KSU,
   KX, RE, SX, UX, statusregister'rst}: StatusRegister, x') =
  {BEV = BEV, CU0 = CU0, ERL = ERL, EXL = EXL, FR = FR, IE = IE,
   IM0 = IM0, IM1 = IM1, KSU = KSU, KX = KX, RE = RE, SX = x', UX = UX,
   statusregister'rst = statusregister'rst}: StatusRegister

fun StatusRegister_UX_rupd ({BEV, CU0, ERL, EXL, FR, IE, IM0, IM1, KSU,
   KX, RE, SX, UX, statusregister'rst}: StatusRegister, x') =
  {BEV = BEV, CU0 = CU0, ERL = ERL, EXL = EXL, FR = FR, IE = IE,
   IM0 = IM0, IM1 = IM1, KSU = KSU, KX = KX, RE = RE, SX = SX, UX = x',
   statusregister'rst = statusregister'rst}: StatusRegister

fun StatusRegister_statusregister'rst_rupd ({BEV, CU0, ERL, EXL, FR, IE,
   IM0, IM1, KSU, KX, RE, SX, UX, statusregister'rst}
  : StatusRegister, x') =
  {BEV = BEV, CU0 = CU0, ERL = ERL, EXL = EXL, FR = FR, IE = IE,
   IM0 = IM0, IM1 = IM1, KSU = KSU, KX = KX, RE = RE, SX = SX, UX = UX,
   statusregister'rst = x'}: StatusRegister

fun ConfigRegister_BE_rupd ({BE, configregister'rst}
  : ConfigRegister, x') =
  {BE = x', configregister'rst = configregister'rst}: ConfigRegister

fun ConfigRegister_configregister'rst_rupd ({BE, configregister'rst}
  : ConfigRegister, x') = {BE = BE, configregister'rst = x'}
  : ConfigRegister

fun CauseRegister_BD_rupd ({BD, ExcCode, causeregister'rst}
  : CauseRegister, x') =
  {BD = x', ExcCode = ExcCode, causeregister'rst = causeregister'rst}
  : CauseRegister

fun CauseRegister_ExcCode_rupd ({BD, ExcCode, causeregister'rst}
  : CauseRegister, x') =
  {BD = BD, ExcCode = x', causeregister'rst = causeregister'rst}
  : CauseRegister

fun CauseRegister_causeregister'rst_rupd ({BD, ExcCode, causeregister'rst}
  : CauseRegister, x') =
  {BD = BD, ExcCode = ExcCode, causeregister'rst = x'}: CauseRegister

fun CP0_BadVAddr_rupd ({BadVAddr, Cause, Compare, Config, Count, Debug,
   EPC, ErrCtl, ErrorEPC, LLAddr, PRId, Status}: CP0, x') =
  {BadVAddr = x', Cause = Cause, Compare = Compare, Config = Config,
   Count = Count, Debug = Debug, EPC = EPC, ErrCtl = ErrCtl,
   ErrorEPC = ErrorEPC, LLAddr = LLAddr, PRId = PRId, Status = Status}
  : CP0

fun CP0_Cause_rupd ({BadVAddr, Cause, Compare, Config, Count, Debug, EPC,
   ErrCtl, ErrorEPC, LLAddr, PRId, Status}: CP0, x') =
  {BadVAddr = BadVAddr, Cause = x', Compare = Compare, Config = Config,
   Count = Count, Debug = Debug, EPC = EPC, ErrCtl = ErrCtl,
   ErrorEPC = ErrorEPC, LLAddr = LLAddr, PRId = PRId, Status = Status}
  : CP0

fun CP0_Compare_rupd ({BadVAddr, Cause, Compare, Config, Count, Debug,
   EPC, ErrCtl, ErrorEPC, LLAddr, PRId, Status}: CP0, x') =
  {BadVAddr = BadVAddr, Cause = Cause, Compare = x', Config = Config,
   Count = Count, Debug = Debug, EPC = EPC, ErrCtl = ErrCtl,
   ErrorEPC = ErrorEPC, LLAddr = LLAddr, PRId = PRId, Status = Status}
  : CP0

fun CP0_Config_rupd ({BadVAddr, Cause, Compare, Config, Count, Debug, EPC,
   ErrCtl, ErrorEPC, LLAddr, PRId, Status}: CP0, x') =
  {BadVAddr = BadVAddr, Cause = Cause, Compare = Compare, Config = x',
   Count = Count, Debug = Debug, EPC = EPC, ErrCtl = ErrCtl,
   ErrorEPC = ErrorEPC, LLAddr = LLAddr, PRId = PRId, Status = Status}
  : CP0

fun CP0_Count_rupd ({BadVAddr, Cause, Compare, Config, Count, Debug, EPC,
   ErrCtl, ErrorEPC, LLAddr, PRId, Status}: CP0, x') =
  {BadVAddr = BadVAddr, Cause = Cause, Compare = Compare, Config = Config,
   Count = x', Debug = Debug, EPC = EPC, ErrCtl = ErrCtl,
   ErrorEPC = ErrorEPC, LLAddr = LLAddr, PRId = PRId, Status = Status}
  : CP0

fun CP0_Debug_rupd ({BadVAddr, Cause, Compare, Config, Count, Debug, EPC,
   ErrCtl, ErrorEPC, LLAddr, PRId, Status}: CP0, x') =
  {BadVAddr = BadVAddr, Cause = Cause, Compare = Compare, Config = Config,
   Count = Count, Debug = x', EPC = EPC, ErrCtl = ErrCtl,
   ErrorEPC = ErrorEPC, LLAddr = LLAddr, PRId = PRId, Status = Status}
  : CP0

fun CP0_EPC_rupd ({BadVAddr, Cause, Compare, Config, Count, Debug, EPC,
   ErrCtl, ErrorEPC, LLAddr, PRId, Status}: CP0, x') =
  {BadVAddr = BadVAddr, Cause = Cause, Compare = Compare, Config = Config,
   Count = Count, Debug = Debug, EPC = x', ErrCtl = ErrCtl,
   ErrorEPC = ErrorEPC, LLAddr = LLAddr, PRId = PRId, Status = Status}
  : CP0

fun CP0_ErrCtl_rupd ({BadVAddr, Cause, Compare, Config, Count, Debug, EPC,
   ErrCtl, ErrorEPC, LLAddr, PRId, Status}: CP0, x') =
  {BadVAddr = BadVAddr, Cause = Cause, Compare = Compare, Config = Config,
   Count = Count, Debug = Debug, EPC = EPC, ErrCtl = x',
   ErrorEPC = ErrorEPC, LLAddr = LLAddr, PRId = PRId, Status = Status}
  : CP0

fun CP0_ErrorEPC_rupd ({BadVAddr, Cause, Compare, Config, Count, Debug,
   EPC, ErrCtl, ErrorEPC, LLAddr, PRId, Status}: CP0, x') =
  {BadVAddr = BadVAddr, Cause = Cause, Compare = Compare, Config = Config,
   Count = Count, Debug = Debug, EPC = EPC, ErrCtl = ErrCtl,
   ErrorEPC = x', LLAddr = LLAddr, PRId = PRId, Status = Status}: CP0

fun CP0_LLAddr_rupd ({BadVAddr, Cause, Compare, Config, Count, Debug, EPC,
   ErrCtl, ErrorEPC, LLAddr, PRId, Status}: CP0, x') =
  {BadVAddr = BadVAddr, Cause = Cause, Compare = Compare, Config = Config,
   Count = Count, Debug = Debug, EPC = EPC, ErrCtl = ErrCtl,
   ErrorEPC = ErrorEPC, LLAddr = x', PRId = PRId, Status = Status}: CP0

fun CP0_PRId_rupd ({BadVAddr, Cause, Compare, Config, Count, Debug, EPC,
   ErrCtl, ErrorEPC, LLAddr, PRId, Status}: CP0, x') =
  {BadVAddr = BadVAddr, Cause = Cause, Compare = Compare, Config = Config,
   Count = Count, Debug = Debug, EPC = EPC, ErrCtl = ErrCtl,
   ErrorEPC = ErrorEPC, LLAddr = LLAddr, PRId = x', Status = Status}: CP0

fun CP0_Status_rupd ({BadVAddr, Cause, Compare, Config, Count, Debug, EPC,
   ErrCtl, ErrorEPC, LLAddr, PRId, Status}: CP0, x') =
  {BadVAddr = BadVAddr, Cause = Cause, Compare = Compare, Config = Config,
   Count = Count, Debug = Debug, EPC = EPC, ErrCtl = ErrCtl,
   ErrorEPC = ErrorEPC, LLAddr = LLAddr, PRId = PRId, Status = x'}: CP0

(* -------------------------------------------------------------------------
   Exceptions
   ------------------------------------------------------------------------- *)

exception UNPREDICTABLE of string

(* -------------------------------------------------------------------------
   Global variables (state)
   ------------------------------------------------------------------------- *)

val BranchDelay = ref (NONE): (BitsN.nbit option) ref

val BranchTo = ref (NONE): (BitsN.nbit option) ref

val CP0 = ref
  ({BadVAddr = BitsN.B(0x0,64),
    Cause =
      {BD = false, ExcCode = BitsN.B(0x0,5),
       causeregister'rst = BitsN.B(0x0,26)}, Compare = BitsN.B(0x0,32),
    Config = {BE = false, configregister'rst = BitsN.B(0x0,31)},
    Count = BitsN.B(0x0,32), Debug = BitsN.B(0x0,32),
    EPC = BitsN.B(0x0,64), ErrCtl = BitsN.B(0x0,32),
    ErrorEPC = BitsN.B(0x0,64), LLAddr = BitsN.B(0x0,64),
    PRId = BitsN.B(0x0,32),
    Status =
      {BEV = false, CU0 = false, ERL = false, EXL = false, FR = false,
       IE = false, IM0 = false, IM1 = false, KSU = BitsN.B(0x0,2),
       KX = false, RE = false, SX = false, UX = false,
       statusregister'rst = BitsN.B(0x0,18)}}): CP0 ref

val LLbit = ref (NONE): (bool option) ref

val MEM = ref (Map.mkMap(SOME 2305843009213693952,BitsN.B(0x0,64)))
  : (BitsN.nbit Map.map) ref

val PC = ref (BitsN.B(0x0,64)): BitsN.nbit ref

val exceptionSignalled = ref (false): bool ref

val gpr = ref (Map.mkMap(SOME 32,BitsN.B(0x0,64)))
  : (BitsN.nbit Map.map) ref

val hi = ref (NONE): (BitsN.nbit option) ref

val lo = ref (NONE): (BitsN.nbit option) ref

val log = ref ([]): (event list) ref

(* -------------------------------------------------------------------------
   Main specification
   ------------------------------------------------------------------------- *)

local
  fun tuple'6 [t0,t1,t2,t3,t4,t5] = (t0,(t1,(t2,(t3,(t4,t5)))))
    | tuple'6 (_: bool list) = raise Fail "tuple'6"
in
  val boolify'6 = tuple'6 o BitsN.toList
end

local
  fun tuple'5 [t0,t1,t2,t3,t4] = (t0,(t1,(t2,(t3,t4))))
    | tuple'5 (_: bool list) = raise Fail "tuple'5"
in
  val boolify'5 = tuple'5 o BitsN.toList
end

local
  fun tuple'26 [t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11,t12,t13,t14,t15,t16,
                t17,t18,t19,t20,t21,t22,t23,t24,t25] =
      (t0,
       (t1,
        (t2,
         (t3,
          (t4,
           (t5,
            (t6,
             (t7,
              (t8,
               (t9,
                (t10,
                 (t11,
                  (t12,
                   (t13,
                    (t14,
                     (t15,
                      (t16,
                       (t17,(t18,(t19,(t20,(t21,(t22,(t23,(t24,t25)))))))))))))))))))))))))
    | tuple'26 (_: bool list) = raise Fail "tuple'26"
in
  val boolify'26 = tuple'26 o BitsN.toList
end

local
  fun tuple'32 [t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11,t12,t13,t14,t15,t16,
                t17,t18,t19,t20,t21,t22,t23,t24,t25,t26,t27,t28,t29,t30,
                t31] =
      (t0,
       (t1,
        (t2,
         (t3,
          (t4,
           (t5,
            (t6,
             (t7,
              (t8,
               (t9,
                (t10,
                 (t11,
                  (t12,
                   (t13,
                    (t14,
                     (t15,
                      (t16,
                       (t17,
                        (t18,
                         (t19,
                          (t20,
                           (t21,
                            (t22,
                             (t23,
                              (t24,(t25,(t26,(t27,(t28,(t29,(t30,t31)))))))))))))))))))))))))))))))
    | tuple'32 (_: bool list) = raise Fail "tuple'32"
in
  val boolify'32 = tuple'32 o BitsN.toList
end

fun rec'StatusRegister x =
  {BEV = BitsN.bit(x,22), CU0 = BitsN.bit(x,28), ERL = BitsN.bit(x,2),
   EXL = BitsN.bit(x,1), FR = BitsN.bit(x,26), IE = BitsN.bit(x,0),
   IM0 = BitsN.bit(x,8), IM1 = BitsN.bit(x,9), KSU = BitsN.bits(x,4,3),
   KX = BitsN.bit(x,7), RE = BitsN.bit(x,25), SX = BitsN.bit(x,6),
   UX = BitsN.bit(x,5),
   statusregister'rst =
     BitsN.concat
       [BitsN.bits(x,21,10),BitsN.bits(x,24,23),BitsN.bits(x,27,27),
        BitsN.bits(x,31,29)]};

fun reg'StatusRegister x =
  case x of
     {BEV = BEV, CU0 = CU0, ERL = ERL, EXL = EXL, FR = FR, IE = IE,
      IM0 = IM0, IM1 = IM1, KSU = KSU, KX = KX, RE = RE, SX = SX, UX = UX,
      statusregister'rst = statusregister'rst} =>
      BitsN.modify
        (fn (i,_) =>
           if i = 31
             then BitsN.bit(statusregister'rst,2)
           else if i = 30
             then BitsN.bit(statusregister'rst,1)
           else if i = 29
             then BitsN.bit(statusregister'rst,0)
           else if i = 28
             then CU0
           else if i = 27
             then BitsN.bit(statusregister'rst,3)
           else if i = 26
             then FR
           else if i = 25
             then RE
           else if i = 24
             then BitsN.bit(statusregister'rst,5)
           else if i = 23
             then BitsN.bit(statusregister'rst,4)
           else if i = 22
             then BEV
           else if i = 21
             then BitsN.bit(statusregister'rst,17)
           else if i = 20
             then BitsN.bit(statusregister'rst,16)
           else if i = 19
             then BitsN.bit(statusregister'rst,15)
           else if i = 18
             then BitsN.bit(statusregister'rst,14)
           else if i = 17
             then BitsN.bit(statusregister'rst,13)
           else if i = 16
             then BitsN.bit(statusregister'rst,12)
           else if i = 15
             then BitsN.bit(statusregister'rst,11)
           else if i = 14
             then BitsN.bit(statusregister'rst,10)
           else if i = 13
             then BitsN.bit(statusregister'rst,9)
           else if i = 12
             then BitsN.bit(statusregister'rst,8)
           else if i = 11
             then BitsN.bit(statusregister'rst,7)
           else if i = 10
             then BitsN.bit(statusregister'rst,6)
           else if i = 9
             then IM1
           else if i = 8
             then IM0
           else if i = 7
             then KX
           else if i = 6
             then SX
           else if i = 5
             then UX
           else if i = 4
             then BitsN.bit(KSU,1)
           else if i = 3
             then BitsN.bit(KSU,0)
           else if i = 2 then ERL else if i = 1 then EXL else IE,
         BitsN.B(0x0,32));

fun write'rec'StatusRegister (_,x) = reg'StatusRegister x;

fun write'reg'StatusRegister (_,x) = rec'StatusRegister x;

fun rec'ConfigRegister x =
  {BE = BitsN.bit(x,15),
   configregister'rst = BitsN.@@(BitsN.bits(x,14,0),BitsN.bits(x,31,16))};

fun reg'ConfigRegister x =
  case x of
     {BE = BE, configregister'rst = configregister'rst} =>
      BitsN.modify
        (fn (i,_) =>
           if i = 31
             then BitsN.bit(configregister'rst,15)
           else if i = 30
             then BitsN.bit(configregister'rst,14)
           else if i = 29
             then BitsN.bit(configregister'rst,13)
           else if i = 28
             then BitsN.bit(configregister'rst,12)
           else if i = 27
             then BitsN.bit(configregister'rst,11)
           else if i = 26
             then BitsN.bit(configregister'rst,10)
           else if i = 25
             then BitsN.bit(configregister'rst,9)
           else if i = 24
             then BitsN.bit(configregister'rst,8)
           else if i = 23
             then BitsN.bit(configregister'rst,7)
           else if i = 22
             then BitsN.bit(configregister'rst,6)
           else if i = 21
             then BitsN.bit(configregister'rst,5)
           else if i = 20
             then BitsN.bit(configregister'rst,4)
           else if i = 19
             then BitsN.bit(configregister'rst,3)
           else if i = 18
             then BitsN.bit(configregister'rst,2)
           else if i = 17
             then BitsN.bit(configregister'rst,1)
           else if i = 16
             then BitsN.bit(configregister'rst,0)
           else if i = 15
             then BE
           else if i = 14
             then BitsN.bit(configregister'rst,30)
           else if i = 13
             then BitsN.bit(configregister'rst,29)
           else if i = 12
             then BitsN.bit(configregister'rst,28)
           else if i = 11
             then BitsN.bit(configregister'rst,27)
           else if i = 10
             then BitsN.bit(configregister'rst,26)
           else if i = 9
             then BitsN.bit(configregister'rst,25)
           else if i = 8
             then BitsN.bit(configregister'rst,24)
           else if i = 7
             then BitsN.bit(configregister'rst,23)
           else if i = 6
             then BitsN.bit(configregister'rst,22)
           else if i = 5
             then BitsN.bit(configregister'rst,21)
           else if i = 4
             then BitsN.bit(configregister'rst,20)
           else if i = 3
             then BitsN.bit(configregister'rst,19)
           else if i = 2
             then BitsN.bit(configregister'rst,18)
           else if i = 1
             then BitsN.bit(configregister'rst,17)
           else BitsN.bit(configregister'rst,16),BitsN.B(0x0,32));

fun write'rec'ConfigRegister (_,x) = reg'ConfigRegister x;

fun write'reg'ConfigRegister (_,x) = rec'ConfigRegister x;

fun rec'CauseRegister x =
  {BD = BitsN.bit(x,31), ExcCode = BitsN.bits(x,6,2),
   causeregister'rst = BitsN.@@(BitsN.bits(x,1,0),BitsN.bits(x,30,7))};

fun reg'CauseRegister x =
  case x of
     {BD = BD, ExcCode = ExcCode, causeregister'rst = causeregister'rst} =>
      BitsN.modify
        (fn (i,_) =>
           if i = 31
             then BD
           else if i = 30
             then BitsN.bit(causeregister'rst,23)
           else if i = 29
             then BitsN.bit(causeregister'rst,22)
           else if i = 28
             then BitsN.bit(causeregister'rst,21)
           else if i = 27
             then BitsN.bit(causeregister'rst,20)
           else if i = 26
             then BitsN.bit(causeregister'rst,19)
           else if i = 25
             then BitsN.bit(causeregister'rst,18)
           else if i = 24
             then BitsN.bit(causeregister'rst,17)
           else if i = 23
             then BitsN.bit(causeregister'rst,16)
           else if i = 22
             then BitsN.bit(causeregister'rst,15)
           else if i = 21
             then BitsN.bit(causeregister'rst,14)
           else if i = 20
             then BitsN.bit(causeregister'rst,13)
           else if i = 19
             then BitsN.bit(causeregister'rst,12)
           else if i = 18
             then BitsN.bit(causeregister'rst,11)
           else if i = 17
             then BitsN.bit(causeregister'rst,10)
           else if i = 16
             then BitsN.bit(causeregister'rst,9)
           else if i = 15
             then BitsN.bit(causeregister'rst,8)
           else if i = 14
             then BitsN.bit(causeregister'rst,7)
           else if i = 13
             then BitsN.bit(causeregister'rst,6)
           else if i = 12
             then BitsN.bit(causeregister'rst,5)
           else if i = 11
             then BitsN.bit(causeregister'rst,4)
           else if i = 10
             then BitsN.bit(causeregister'rst,3)
           else if i = 9
             then BitsN.bit(causeregister'rst,2)
           else if i = 8
             then BitsN.bit(causeregister'rst,1)
           else if i = 7
             then BitsN.bit(causeregister'rst,0)
           else if i = 6
             then BitsN.bit(ExcCode,4)
           else if i = 5
             then BitsN.bit(ExcCode,3)
           else if i = 4
             then BitsN.bit(ExcCode,2)
           else if i = 3
             then BitsN.bit(ExcCode,1)
           else if i = 2
             then BitsN.bit(ExcCode,0)
           else if i = 1
             then BitsN.bit(causeregister'rst,25)
           else BitsN.bit(causeregister'rst,24),BitsN.B(0x0,32));

fun write'rec'CauseRegister (_,x) = reg'CauseRegister x;

fun write'reg'CauseRegister (_,x) = rec'CauseRegister x;

fun ExceptionCode ExceptionType =
  case ExceptionType of
     AdEL => BitsN.B(0x4,5)
   | AdES => BitsN.B(0x5,5)
   | Sys => BitsN.B(0x8,5)
   | Bp => BitsN.B(0x9,5)
   | RI => BitsN.B(0xA,5)
   | CpU => BitsN.B(0xB,5)
   | Ov => BitsN.B(0xC,5)
   | Tr => BitsN.B(0xD,5);

fun SignalException ExceptionType =
  ( if not((#EXL)((#Status) (!CP0)))
      then if Option.isSome (!BranchDelay)
             then ( CP0 :=
                    (CP0_EPC_rupd((!CP0),BitsN.-((!PC),BitsN.B(0x4,64))))
                  ; let
                      val x0 = (#Cause) (!CP0)
                    in
                      CP0 :=
                      (CP0_Cause_rupd
                         ((!CP0),CauseRegister_BD_rupd(x0,true)))
                    end
                  )
           else ( CP0 := (CP0_EPC_rupd((!CP0),(!PC)))
                ; let
                    val x0 = (#Cause) (!CP0)
                  in
                    CP0 :=
                    (CP0_Cause_rupd
                       ((!CP0),CauseRegister_BD_rupd(x0,false)))
                  end
                )
    else ()
  ; let
      val vectorOffset = BitsN.B(0x180,30)
    in
      ( let
          val x0 = (#Cause) (!CP0)
        in
          CP0 :=
          (CP0_Cause_rupd
             ((!CP0),
              CauseRegister_ExcCode_rupd(x0,ExceptionCode ExceptionType)))
        end
      ; let
          val x0 = (#Status) (!CP0)
        in
          CP0 :=
          (CP0_Status_rupd((!CP0),StatusRegister_EXL_rupd(x0,true)))
        end
      ; let
          val vectorBase =
            if (#BEV)((#Status) (!CP0))
              then BitsN.B(0xFFFFFFFFBFC00200,64)
            else BitsN.B(0xFFFFFFFF80000000,64)
        in
          ( BranchDelay := NONE
          ; BranchTo := NONE
          ; PC :=
            (BitsN.@@
               (BitsN.bits(vectorBase,63,30),
                BitsN.+(BitsN.bits(vectorBase,29,0),vectorOffset)))
          ; exceptionSignalled := true
          )
        end
      )
    end
  );

val BYTE = BitsN.B(0x0,3)

val HALFWORD = BitsN.B(0x1,3)

val WORD = BitsN.B(0x3,3)

val DOUBLEWORD = BitsN.B(0x7,3)

val PSIZE = 64

fun KernelMode () =
  ((((#KSU)((#Status) (!CP0))) = (BitsN.B(0x0,2))) orelse
   ((#EXL)((#Status) (!CP0)))) orelse ((#ERL)((#Status) (!CP0)));

fun UserMode () =
  ((((#KSU)((#Status) (!CP0))) = (BitsN.B(0x2,2))) andalso
   (not((#EXL)((#Status) (!CP0))))) andalso
  (not((#ERL)((#Status) (!CP0))));

fun BigEndianMem () = (#BE)((#Config) (!CP0));

fun ReverseEndian () =
  BitsN.fromBit(((#RE)((#Status) (!CP0))) andalso (UserMode ()));

fun BigEndianCPU () =
  BitsN.??(BitsN.fromBit(BigEndianMem ()),ReverseEndian ());

fun mark e = log := (e :: (!log));

fun GPR n =
  if n = (BitsN.B(0x0,5))
    then BitsN.B(0x0,64)
  else Map.lookup((!gpr),BitsN.toNat n);

fun write'GPR (value,n) =
  if not(n = (BitsN.B(0x0,5)))
    then ( gpr := (Map.update((!gpr),BitsN.toNat n,value))
         ; mark(w_gpr(n,value))
         )
  else ();

fun HI () =
  case (!hi) of Option.SOME v => v | NONE => raise UNPREDICTABLE ("HI");

fun write'HI value = ( hi := (Option.SOME value); mark(w_hi value) );

fun LO () =
  case (!lo) of Option.SOME v => v | NONE => raise UNPREDICTABLE ("LO");

fun write'LO value = ( lo := (Option.SOME value); mark(w_lo value) );

fun CPR (n,(reg,sel)) =
  case (n,(reg,sel)) of
     (0,(BitsN.B(0x8,5),BitsN.B(0x0,3))) => (#BadVAddr) (!CP0)
   | (0,(BitsN.B(0x9,5),BitsN.B(0x0,3))) =>
        BitsN.fromNat(BitsN.toNat((#Count) (!CP0)),64)
   | (0,(BitsN.B(0xB,5),BitsN.B(0x0,3))) =>
        BitsN.fromNat(BitsN.toNat((#Compare) (!CP0)),64)
   | (0,(BitsN.B(0xC,5),BitsN.B(0x0,3))) =>
        BitsN.fromNat
          (BitsN.toNat(reg'StatusRegister((#Status) (!CP0))),64)
   | (0,(BitsN.B(0xD,5),BitsN.B(0x0,3))) =>
        BitsN.fromNat(BitsN.toNat(reg'CauseRegister((#Cause) (!CP0))),64)
   | (0,(BitsN.B(0xE,5),BitsN.B(0x0,3))) => (#EPC) (!CP0)
   | (0,(BitsN.B(0xF,5),BitsN.B(0x0,3))) =>
        BitsN.fromNat(BitsN.toNat((#PRId) (!CP0)),64)
   | (0,(BitsN.B(0x10,5),BitsN.B(0x0,3))) =>
        BitsN.fromNat
          (BitsN.toNat(reg'ConfigRegister((#Config) (!CP0))),64)
   | (0,(BitsN.B(0x11,5),BitsN.B(0x0,3))) =>
        BitsN.fromNat(BitsN.toNat((#LLAddr) (!CP0)),64)
   | (0,(BitsN.B(0x17,5),BitsN.B(0x0,3))) =>
        BitsN.fromNat(BitsN.toNat((#Debug) (!CP0)),64)
   | (0,(BitsN.B(0x1A,5),BitsN.B(0x0,3))) =>
        BitsN.fromNat(BitsN.toNat((#ErrCtl) (!CP0)),64)
   | (0,(BitsN.B(0x1E,5),BitsN.B(0x0,3))) => (#ErrorEPC) (!CP0)
   | _ => BitsN.B(0x0,64);

fun write'CPR (value,(n,(reg,sel))) =
  case (n,(reg,sel)) of
     (0,(BitsN.B(0x9,5),BitsN.B(0x0,3))) =>
        ( CP0 := (CP0_Count_rupd((!CP0),BitsN.bits(value,31,0)))
        ; mark(w_c0(reg,value))
        )
   | (0,(BitsN.B(0xB,5),BitsN.B(0x0,3))) =>
        ( CP0 := (CP0_Compare_rupd((!CP0),BitsN.bits(value,31,0)))
        ; mark(w_c0(reg,value))
        )
   | (0,(BitsN.B(0xC,5),BitsN.B(0x0,3))) =>
        ( let
            val x0 = (#Status) (!CP0)
          in
            CP0 :=
            (CP0_Status_rupd
               ((!CP0),write'reg'StatusRegister(x0,BitsN.bits(value,31,0))))
          end
        ; mark(w_c0(reg,value))
        )
   | (0,(BitsN.B(0xD,5),BitsN.B(0x0,3))) =>
        ( let
            val x0 = (#Cause) (!CP0)
          in
            CP0 :=
            (CP0_Cause_rupd
               ((!CP0),write'reg'CauseRegister(x0,BitsN.bits(value,31,0))))
          end
        ; mark(w_c0(reg,value))
        )
   | (0,(BitsN.B(0xE,5),BitsN.B(0x0,3))) =>
        ( CP0 := (CP0_EPC_rupd((!CP0),value)); mark(w_c0(reg,value)) )
   | (0,(BitsN.B(0x10,5),BitsN.B(0x0,3))) =>
        ( let
            val x0 = (#Config) (!CP0)
          in
            CP0 :=
            (CP0_Config_rupd
               ((!CP0),write'reg'ConfigRegister(x0,BitsN.bits(value,31,0))))
          end
        ; mark(w_c0(reg,value))
        )
   | (0,(BitsN.B(0x17,5),BitsN.B(0x0,3))) =>
        ( CP0 := (CP0_Debug_rupd((!CP0),BitsN.bits(value,31,0)))
        ; mark(w_c0(reg,value))
        )
   | (0,(BitsN.B(0x1A,5),BitsN.B(0x0,3))) =>
        ( CP0 := (CP0_ErrCtl_rupd((!CP0),BitsN.bits(value,31,0)))
        ; mark(w_c0(reg,value))
        )
   | (0,(BitsN.B(0x1E,5),BitsN.B(0x0,3))) =>
        ( CP0 := (CP0_ErrorEPC_rupd((!CP0),value))
        ; mark(w_c0(reg,value))
        )
   | _ => ();

fun AddressTranslation (vAddr,(IorD,LorS)) =
  (BitsN.&&(vAddr,BitsN.B(0xFFFFFFFFFFFFFF,64)),BitsN.B(0x0,3));

fun LoadMemory (CCA,(AccessLength,(pAddr,(vAddr,IorD)))) =
  Map.lookup((!MEM),BitsN.toNat(BitsN.bits(pAddr,63,3)));

fun StoreMemory (CCA,(AccessLength,(MemElem,(pAddr,(vAddr,IorD))))) =
  let
    val a = BitsN.bits(pAddr,63,3)
    val l =
      Nat.-
        (64,
         Nat.*
           (Nat.+
              (Nat.+(BitsN.toNat AccessLength,1),
               BitsN.toNat(BitsN.bits(pAddr,2,0))),8))
    val mask =
      BitsN.fromNat
        (Nat.-
           (Nat.pow(2,Nat.+(l,Nat.*(Nat.+(BitsN.toNat AccessLength,1),8))),
            Nat.pow(2,l)),64)
  in
    ( MEM :=
      (Map.update
         ((!MEM),BitsN.toNat a,
          BitsN.||
            (BitsN.&&(Map.lookup((!MEM),BitsN.toNat a),BitsN.~ mask),
             BitsN.&&(MemElem,mask))))
    ; mark(w_mem(pAddr,(mask,(AccessLength,MemElem))))
    )
  end;

fun Fetch () =
  ( log := []
  ; if (BitsN.bits((!PC),1,0)) = (BitsN.B(0x0,2))
      then let
             val d =
               Map.lookup
                 ((!MEM),
                  BitsN.toNat
                    (BitsN.fromNat(BitsN.toNat(BitsN.bits((!PC),55,3)),61)))
           in
             Option.SOME
               (if BitsN.bit((!PC),2)
                  then BitsN.bits(d,31,0)
                else BitsN.bits(d,63,32))
           end
    else NONE
  );

fun initMips pc =
  ( CP0 := (CP0_Count_rupd((!CP0),BitsN.B(0x0,32)))
  ; let
      val x0 = (#Config) (!CP0)
    in
      CP0 := (CP0_Config_rupd((!CP0),ConfigRegister_BE_rupd(x0,true)))
    end
  ; let
      val x0 = (#Status) (!CP0)
    in
      CP0 :=
      (CP0_Status_rupd
         ((!CP0),write'reg'StatusRegister(x0,BitsN.B(0x44000E0,32))))
    end
  ; CP0 := (CP0_PRId_rupd((!CP0),BitsN.B(0x400,32)))
  ; BranchDelay := NONE
  ; BranchTo := NONE
  ; LLbit := NONE
  ; hi := NONE
  ; lo := NONE
  ; PC := (BitsN.fromNat(pc,64))
  ; MEM := (Map.mkMap(SOME 2305843009213693952,BitsN.B(0x0,64)))
  ; gpr := (Map.mkMap(SOME 32,BitsN.B(0xAAAAAAAAAAAAAAAA,64)))
  );

fun done () =
  (case (!log) of [w_c0(BitsN.B(0x17,5),_)] => true | _ => false) orelse
  (case (!BranchDelay) of
      Option.SOME addr => addr = (BitsN.-((!PC),BitsN.B(0x8,64)))
    | NONE => false);

fun NotWordValue value =
  let
    val top = BitsN.bits(value,63,32)
  in
    if BitsN.bit(value,31)
      then not(top = (BitsN.B(0xFFFFFFFF,32)))
    else not(top = (BitsN.B(0x0,32)))
  end;

fun dfn'ADDI (rs,(rt,immediate)) =
  ( if NotWordValue(GPR rs)
      then raise UNPREDICTABLE ("ADDI: NotWordValue")
    else ()
  ; let
      val temp =
        BitsN.+(BitsN.bits(GPR rs,32,0),BitsN.signExtend 33 immediate)
    in
      if not((BitsN.bit(temp,32)) = (BitsN.bit(temp,31)))
        then SignalException Ov
      else write'GPR(BitsN.signExtend 64 (BitsN.bits(temp,31,0)),rt)
    end
  );

fun dfn'ADDIU (rs,(rt,immediate)) =
  ( if NotWordValue(GPR rs)
      then raise UNPREDICTABLE ("ADDIU: NotWordValue")
    else ()
  ; let
      val temp =
        BitsN.+(BitsN.bits(GPR rs,31,0),BitsN.signExtend 32 immediate)
    in
      write'GPR(BitsN.signExtend 64 temp,rt)
    end
  );

fun dfn'DADDI (rs,(rt,immediate)) =
  let
    val temp =
      BitsN.+(BitsN.signExtend 65 (GPR rs),BitsN.signExtend 65 immediate)
  in
    if not((BitsN.bit(temp,64)) = (BitsN.bit(temp,63)))
      then SignalException Ov
    else write'GPR(BitsN.bits(temp,63,0),rt)
  end;

fun dfn'DADDIU (rs,(rt,immediate)) =
  write'GPR(BitsN.+(GPR rs,BitsN.signExtend 64 immediate),rt);

fun dfn'SLTI (rs,(rt,immediate)) =
  write'GPR
    (BitsN.fromBool 64 (BitsN.<(GPR rs,BitsN.signExtend 64 immediate)),rt);

fun dfn'SLTIU (rs,(rt,immediate)) =
  write'GPR
    (BitsN.fromBool 64 (BitsN.<+(GPR rs,BitsN.signExtend 64 immediate)),rt);

fun dfn'ANDI (rs,(rt,immediate)) =
  write'GPR(BitsN.&&(GPR rs,BitsN.zeroExtend 64 immediate),rt);

fun dfn'ORI (rs,(rt,immediate)) =
  write'GPR(BitsN.||(GPR rs,BitsN.zeroExtend 64 immediate),rt);

fun dfn'XORI (rs,(rt,immediate)) =
  write'GPR(BitsN.??(GPR rs,BitsN.zeroExtend 64 immediate),rt);

fun dfn'LUI (rt,immediate) =
  write'GPR(BitsN.signExtend 64 (BitsN.@@(immediate,BitsN.B(0x0,16))),rt);

fun dfn'ADD (rs,(rt,rd)) =
  ( if (NotWordValue(GPR rs)) orelse (NotWordValue(GPR rt))
      then raise UNPREDICTABLE ("ADD: NotWordValue")
    else ()
  ; let
      val temp = BitsN.+(BitsN.bits(GPR rs,32,0),BitsN.bits(GPR rt,32,0))
    in
      if not((BitsN.bit(temp,32)) = (BitsN.bit(temp,31)))
        then SignalException Ov
      else write'GPR(BitsN.signExtend 64 (BitsN.bits(temp,31,0)),rd)
    end
  );

fun dfn'ADDU (rs,(rt,rd)) =
  ( if (NotWordValue(GPR rs)) orelse (NotWordValue(GPR rt))
      then raise UNPREDICTABLE ("ADDU: NotWordValue")
    else ()
  ; let
      val temp = BitsN.+(BitsN.bits(GPR rs,31,0),BitsN.bits(GPR rt,31,0))
    in
      write'GPR(BitsN.signExtend 64 temp,rd)
    end
  );

fun dfn'SUB (rs,(rt,rd)) =
  ( if (NotWordValue(GPR rs)) orelse (NotWordValue(GPR rt))
      then raise UNPREDICTABLE ("SUB: NotWordValue")
    else ()
  ; let
      val temp = BitsN.-(BitsN.bits(GPR rs,32,0),BitsN.bits(GPR rt,32,0))
    in
      if not((BitsN.bit(temp,32)) = (BitsN.bit(temp,31)))
        then SignalException Ov
      else write'GPR(BitsN.signExtend 64 (BitsN.bits(temp,31,0)),rd)
    end
  );

fun dfn'SUBU (rs,(rt,rd)) =
  ( if (NotWordValue(GPR rs)) orelse (NotWordValue(GPR rt))
      then raise UNPREDICTABLE ("SUBU: NotWordValue")
    else ()
  ; let
      val temp = BitsN.-(BitsN.bits(GPR rs,32,0),BitsN.bits(GPR rt,32,0))
    in
      write'GPR(BitsN.signExtend 64 temp,rd)
    end
  );

fun dfn'DADD (rs,(rt,rd)) =
  let
    val temp =
      BitsN.+(BitsN.signExtend 65 (GPR rs),BitsN.signExtend 65 (GPR rt))
  in
    if not((BitsN.bit(temp,64)) = (BitsN.bit(temp,63)))
      then SignalException Ov
    else write'GPR(BitsN.bits(temp,63,0),rd)
  end;

fun dfn'DADDU (rs,(rt,rd)) = write'GPR(BitsN.+(GPR rs,GPR rt),rd);

fun dfn'DSUB (rs,(rt,rd)) =
  let
    val temp =
      BitsN.-(BitsN.signExtend 65 (GPR rs),BitsN.signExtend 65 (GPR rt))
  in
    if not((BitsN.bit(temp,64)) = (BitsN.bit(temp,63)))
      then SignalException Ov
    else write'GPR(BitsN.bits(temp,63,0),rd)
  end;

fun dfn'DSUBU (rs,(rt,rd)) = write'GPR(BitsN.-(GPR rs,GPR rt),rd);

fun dfn'SLT (rs,(rt,rd)) =
  write'GPR(BitsN.fromBool 64 (BitsN.<(GPR rs,GPR rt)),rd);

fun dfn'SLTU (rs,(rt,rd)) =
  write'GPR(BitsN.fromBool 64 (BitsN.<+(GPR rs,GPR rt)),rd);

fun dfn'AND (rs,(rt,rd)) = write'GPR(BitsN.&&(GPR rs,GPR rt),rd);

fun dfn'OR (rs,(rt,rd)) = write'GPR(BitsN.||(GPR rs,GPR rt),rd);

fun dfn'XOR (rs,(rt,rd)) = write'GPR(BitsN.??(GPR rs,GPR rt),rd);

fun dfn'NOR (rs,(rt,rd)) = write'GPR(BitsN.~(BitsN.||(GPR rs,GPR rt)),rd);

fun dfn'MOVN (rs,(rt,rd)) =
  if not((GPR rt) = (BitsN.B(0x0,64))) then write'GPR(GPR rs,rd) else ();

fun dfn'MOVZ (rs,(rt,rd)) =
  if (GPR rt) = (BitsN.B(0x0,64)) then write'GPR(GPR rs,rd) else ();

fun dfn'MADD (rs,rt) =
  ( if (NotWordValue(GPR rs)) orelse (NotWordValue(GPR rt))
      then raise UNPREDICTABLE ("MADD: NotWordValue")
    else ()
  ; let
      val temp =
        BitsN.+
          (BitsN.@@(BitsN.bits(HI (),31,0),BitsN.bits(LO (),31,0)),
           BitsN.*
             (BitsN.signExtend 64 (BitsN.bits(GPR rs,31,0)),
              BitsN.signExtend 64 (BitsN.bits(GPR rt,31,0))))
    in
      ( write'HI(BitsN.signExtend 64 (BitsN.bits(temp,63,32)))
      ; write'LO(BitsN.signExtend 64 (BitsN.bits(temp,31,0)))
      )
    end
  );

fun dfn'MADDU (rs,rt) =
  ( if (NotWordValue(GPR rs)) orelse (NotWordValue(GPR rt))
      then raise UNPREDICTABLE ("MADDU: NotWordValue")
    else ()
  ; let
      val temp =
        BitsN.+
          (BitsN.@@(BitsN.bits(HI (),31,0),BitsN.bits(LO (),31,0)),
           BitsN.*
             (BitsN.zeroExtend 64 (BitsN.bits(GPR rs,31,0)),
              BitsN.zeroExtend 64 (BitsN.bits(GPR rt,31,0))))
    in
      ( write'HI(BitsN.signExtend 64 (BitsN.bits(temp,63,32)))
      ; write'LO(BitsN.signExtend 64 (BitsN.bits(temp,31,0)))
      )
    end
  );

fun dfn'MSUB (rs,rt) =
  ( if (NotWordValue(GPR rs)) orelse (NotWordValue(GPR rt))
      then raise UNPREDICTABLE ("MSUB: NotWordValue")
    else ()
  ; let
      val temp =
        BitsN.-
          (BitsN.@@(BitsN.bits(HI (),31,0),BitsN.bits(LO (),31,0)),
           BitsN.*
             (BitsN.signExtend 64 (BitsN.bits(GPR rs,31,0)),
              BitsN.signExtend 64 (BitsN.bits(GPR rt,31,0))))
    in
      ( write'HI(BitsN.signExtend 64 (BitsN.bits(temp,63,32)))
      ; write'LO(BitsN.signExtend 64 (BitsN.bits(temp,31,0)))
      )
    end
  );

fun dfn'MSUBU (rs,rt) =
  ( if (NotWordValue(GPR rs)) orelse (NotWordValue(GPR rt))
      then raise UNPREDICTABLE ("MSUBU: NotWordValue")
    else ()
  ; let
      val temp =
        BitsN.-
          (BitsN.@@(BitsN.bits(HI (),31,0),BitsN.bits(LO (),31,0)),
           BitsN.*
             (BitsN.zeroExtend 64 (BitsN.bits(GPR rs,31,0)),
              BitsN.zeroExtend 64 (BitsN.bits(GPR rt,31,0))))
    in
      ( write'HI(BitsN.signExtend 64 (BitsN.bits(temp,63,32)))
      ; write'LO(BitsN.signExtend 64 (BitsN.bits(temp,31,0)))
      )
    end
  );

fun dfn'MUL (rs,(rt,rd)) =
  ( if (NotWordValue(GPR rs)) orelse (NotWordValue(GPR rt))
      then raise UNPREDICTABLE ("MUL: NotWordValue")
    else ()
  ; write'GPR
      (BitsN.signExtend 64
         (BitsN.*(BitsN.bits(GPR rs,31,0),BitsN.bits(GPR rt,31,0))),rd)
  ; lo := NONE
  ; hi := NONE
  );

fun dfn'MULT (rs,rt) =
  ( if (NotWordValue(GPR rs)) orelse (NotWordValue(GPR rt))
      then raise UNPREDICTABLE ("MULT: NotWordValue")
    else ()
  ; let
      val prod =
        BitsN.*
          (BitsN.signExtend 64 (BitsN.bits(GPR rs,31,0)),
           BitsN.signExtend 64 (BitsN.bits(GPR rt,31,0)))
    in
      ( write'LO(BitsN.signExtend 64 (BitsN.bits(prod,31,0)))
      ; write'HI(BitsN.signExtend 64 (BitsN.bits(prod,63,32)))
      )
    end
  );

fun dfn'MULTU (rs,rt) =
  ( if (NotWordValue(GPR rs)) orelse (NotWordValue(GPR rt))
      then raise UNPREDICTABLE ("MULTU: NotWordValue")
    else ()
  ; let
      val prod =
        BitsN.*
          (BitsN.zeroExtend 64 (BitsN.bits(GPR rs,31,0)),
           BitsN.zeroExtend 64 (BitsN.bits(GPR rt,31,0)))
    in
      ( write'LO(BitsN.signExtend 64 (BitsN.bits(prod,31,0)))
      ; write'HI(BitsN.signExtend 64 (BitsN.bits(prod,63,32)))
      )
    end
  );

fun dfn'DMULT (rs,rt) =
  let
    val prod =
      BitsN.*(BitsN.signExtend 128 (GPR rs),BitsN.signExtend 128 (GPR rt))
  in
    ( write'LO(BitsN.bits(prod,63,0)); write'HI(BitsN.bits(prod,127,64)) )
  end;

fun dfn'DMULTU (rs,rt) =
  let
    val prod =
      BitsN.*(BitsN.zeroExtend 128 (GPR rs),BitsN.zeroExtend 128 (GPR rt))
  in
    ( write'LO(BitsN.bits(prod,63,0)); write'HI(BitsN.bits(prod,127,64)) )
  end;

fun dfn'DIV (rs,rt) =
  let
    val s = GPR rs
    val t = GPR rt
  in
    ( if (NotWordValue s) orelse (NotWordValue t)
        then raise UNPREDICTABLE ("DIV: NotWordValue")
      else ()
    ; if t = (BitsN.B(0x0,64))
        then ( lo := NONE; hi := NONE )
      else let
             val q = BitsN.quot(BitsN.bits(s,31,0),BitsN.bits(t,31,0))
             val r = BitsN.rem(BitsN.bits(s,31,0),BitsN.bits(t,31,0))
           in
             ( write'LO(BitsN.signExtend 64 q)
             ; write'HI(BitsN.signExtend 64 r)
             )
           end
    )
  end;

fun dfn'DIVU (rs,rt) =
  let
    val s = GPR rs
    val t = GPR rt
  in
    ( if (NotWordValue s) orelse (NotWordValue t)
        then raise UNPREDICTABLE ("DIVU: NotWordValue")
      else ()
    ; if t = (BitsN.B(0x0,64))
        then ( lo := NONE; hi := NONE )
      else let
             val q = BitsN.div(BitsN.bits(s,31,0),BitsN.bits(t,31,0))
             val r = BitsN.mod(BitsN.bits(s,31,0),BitsN.bits(t,31,0))
           in
             ( write'LO(BitsN.signExtend 64 q)
             ; write'HI(BitsN.signExtend 64 r)
             )
           end
    )
  end;

fun dfn'DDIV (rs,rt) =
  let
    val t = GPR rt
  in
    if t = (BitsN.B(0x0,64))
      then ( lo := NONE; hi := NONE )
    else let
           val s = GPR rs
         in
           ( write'LO(BitsN.quot(s,t)); write'HI(BitsN.rem(s,t)) )
         end
  end;

fun dfn'DDIVU (rs,rt) =
  let
    val t = GPR rt
  in
    if t = (BitsN.B(0x0,64))
      then ( lo := NONE; hi := NONE )
    else let
           val s = GPR rs
         in
           ( write'LO(BitsN.div(s,t)); write'HI(BitsN.mod(s,t)) )
         end
  end;

fun dfn'MFHI rd = write'GPR(HI (),rd);

fun dfn'MFLO rd = write'GPR(LO (),rd);

fun dfn'MTHI rs = write'HI(GPR rs);

fun dfn'MTLO rs = write'LO(GPR rs);

fun dfn'SLL (rt,(rd,sa)) =
  write'GPR
    (BitsN.signExtend 64
       (BitsN.<<(BitsN.bits(GPR rt,31,0),BitsN.toNat sa)),rd);

fun dfn'SRL (rt,(rd,sa)) =
  ( if NotWordValue(GPR rt)
      then raise UNPREDICTABLE ("SRL: NotWordValue")
    else ()
  ; write'GPR
      (BitsN.signExtend 64
         (BitsN.>>+(BitsN.bits(GPR rt,31,0),BitsN.toNat sa)),rd)
  );

fun dfn'SRA (rt,(rd,sa)) =
  ( if NotWordValue(GPR rt)
      then raise UNPREDICTABLE ("SRA: NotWordValue")
    else ()
  ; write'GPR
      (BitsN.signExtend 64
         (BitsN.>>(BitsN.bits(GPR rt,31,0),BitsN.toNat sa)),rd)
  );

fun dfn'SLLV (rs,(rt,rd)) =
  let
    val sa = BitsN.bits(GPR rs,4,0)
  in
    write'GPR
      (BitsN.signExtend 64
         (BitsN.<<(BitsN.bits(GPR rt,31,0),BitsN.toNat sa)),rd)
  end;

fun dfn'SRLV (rs,(rt,rd)) =
  ( if NotWordValue(GPR rt)
      then raise UNPREDICTABLE ("SRLV: NotWordValue")
    else ()
  ; let
      val sa = BitsN.bits(GPR rs,4,0)
    in
      write'GPR
        (BitsN.signExtend 64
           (BitsN.>>+(BitsN.bits(GPR rt,31,0),BitsN.toNat sa)),rd)
    end
  );

fun dfn'SRAV (rs,(rt,rd)) =
  ( if NotWordValue(GPR rt)
      then raise UNPREDICTABLE ("SRAV: NotWordValue")
    else ()
  ; let
      val sa = BitsN.bits(GPR rs,4,0)
    in
      write'GPR
        (BitsN.signExtend 64
           (BitsN.>>(BitsN.bits(GPR rt,31,0),BitsN.toNat sa)),rd)
    end
  );

fun dfn'DSLL (rt,(rd,sa)) = write'GPR(BitsN.<<(GPR rt,BitsN.toNat sa),rd);

fun dfn'DSRL (rt,(rd,sa)) =
  write'GPR(BitsN.>>+(GPR rt,BitsN.toNat sa),rd);

fun dfn'DSRA (rt,(rd,sa)) = write'GPR(BitsN.>>(GPR rt,BitsN.toNat sa),rd);

fun dfn'DSLLV (rs,(rt,rd)) =
  let
    val sa = BitsN.bits(GPR rs,5,0)
  in
    write'GPR(BitsN.<<(GPR rt,BitsN.toNat sa),rd)
  end;

fun dfn'DSRLV (rs,(rt,rd)) =
  let
    val sa = BitsN.bits(GPR rs,5,0)
  in
    write'GPR(BitsN.>>+(GPR rt,BitsN.toNat sa),rd)
  end;

fun dfn'DSRAV (rs,(rt,rd)) =
  let
    val sa = BitsN.bits(GPR rs,5,0)
  in
    write'GPR(BitsN.>>(GPR rt,BitsN.toNat sa),rd)
  end;

fun dfn'DSLL32 (rt,(rd,sa)) =
  write'GPR(BitsN.<<(GPR rt,Nat.+(BitsN.toNat sa,32)),rd);

fun dfn'DSRL32 (rt,(rd,sa)) =
  write'GPR(BitsN.>>+(GPR rt,Nat.+(BitsN.toNat sa,32)),rd);

fun dfn'DSRA32 (rt,(rd,sa)) =
  write'GPR(BitsN.>>(GPR rt,Nat.+(BitsN.toNat sa,32)),rd);

fun dfn'TGE (rs,rt) =
  if BitsN.>=(GPR rs,GPR rt) then SignalException Tr else ();

fun dfn'TGEU (rs,rt) =
  if BitsN.>=+(GPR rs,GPR rt) then SignalException Tr else ();

fun dfn'TLT (rs,rt) =
  if BitsN.<(GPR rs,GPR rt) then SignalException Tr else ();

fun dfn'TLTU (rs,rt) =
  if BitsN.<+(GPR rs,GPR rt) then SignalException Tr else ();

fun dfn'TEQ (rs,rt) =
  if (GPR rs) = (GPR rt) then SignalException Tr else ();

fun dfn'TNE (rs,rt) =
  if not((GPR rs) = (GPR rt)) then SignalException Tr else ();

fun dfn'TGEI (rs,immediate) =
  if BitsN.>=(GPR rs,BitsN.signExtend 64 immediate)
    then SignalException Tr
  else ();

fun dfn'TGEIU (rs,immediate) =
  if BitsN.>=+(GPR rs,BitsN.signExtend 64 immediate)
    then SignalException Tr
  else ();

fun dfn'TLTI (rs,immediate) =
  if BitsN.<(GPR rs,BitsN.signExtend 64 immediate)
    then SignalException Tr
  else ();

fun dfn'TLTIU (rs,immediate) =
  if BitsN.<+(GPR rs,BitsN.signExtend 64 immediate)
    then SignalException Tr
  else ();

fun dfn'TEQI (rs,immediate) =
  if (GPR rs) = (BitsN.signExtend 64 immediate)
    then SignalException Tr
  else ();

fun dfn'TNEI (rs,immediate) =
  if not((GPR rs) = (BitsN.signExtend 64 immediate))
    then SignalException Tr
  else ();

fun loadByte (base,(rt,(offset,unsigned))) =
  let
    val vAddr = BitsN.+(BitsN.signExtend 64 offset,GPR base)
    val (pAddr,CCA) = AddressTranslation(vAddr,(DATA,LOAD))
    val pAddr =
      BitsN.@@
        (BitsN.bits(pAddr,Nat.-(PSIZE,1),3),
         BitsN.??
           (BitsN.bits(pAddr,2,0),BitsN.replicate(ReverseEndian (),3)))
    val memdoubleword = LoadMemory(CCA,(BYTE,(pAddr,(vAddr,DATA))))
    val byte =
      BitsN.??(BitsN.bits(vAddr,2,0),BitsN.replicate(BigEndianCPU (),3))
    val membyte =
      BitsN.bits
        (memdoubleword,Nat.+(7,Nat.*(8,BitsN.toNat byte)),
         Nat.*(8,BitsN.toNat byte))
  in
    ( write'GPR
        (if unsigned
           then BitsN.zeroExtend 64 membyte
         else BitsN.signExtend 64 membyte,rt)
    ; LLbit := NONE
    )
  end;

fun loadHalf (base,(rt,(offset,unsigned))) =
  let
    val vAddr = BitsN.+(BitsN.signExtend 64 offset,GPR base)
  in
    if BitsN.bit(vAddr,0)
      then ( CP0 := (CP0_BadVAddr_rupd((!CP0),vAddr))
           ; SignalException AdEL
           )
    else let
           val (pAddr,CCA) = AddressTranslation(vAddr,(DATA,LOAD))
           val pAddr =
             BitsN.@@
               (BitsN.bits(pAddr,Nat.-(PSIZE,1),3),
                BitsN.??
                  (BitsN.bits(pAddr,2,0),
                   BitsN.@@
                     (BitsN.replicate(ReverseEndian (),2),BitsN.B(0x0,1))))
           val memdoubleword =
             LoadMemory(CCA,(HALFWORD,(pAddr,(vAddr,DATA))))
           val byte =
             BitsN.??
               (BitsN.bits(vAddr,2,0),
                BitsN.@@
                  (BitsN.replicate(BigEndianCPU (),2),BitsN.B(0x0,1)))
           val memhalf =
             BitsN.bits
               (memdoubleword,Nat.+(15,Nat.*(8,BitsN.toNat byte)),
                Nat.*(8,BitsN.toNat byte))
         in
           ( write'GPR
               (if unsigned
                  then BitsN.zeroExtend 64 memhalf
                else BitsN.signExtend 64 memhalf,rt)
           ; LLbit := NONE
           )
         end
  end;

fun loadWord (link,(base,(rt,(offset,unsigned)))) =
  let
    val vAddr = BitsN.+(BitsN.signExtend 64 offset,GPR base)
  in
    if not((BitsN.bits(vAddr,1,0)) = (BitsN.B(0x0,2)))
      then ( CP0 := (CP0_BadVAddr_rupd((!CP0),vAddr))
           ; SignalException AdEL
           )
    else let
           val (pAddr,CCA) = AddressTranslation(vAddr,(DATA,LOAD))
           val pAddr =
             BitsN.@@
               (BitsN.bits(pAddr,Nat.-(PSIZE,1),3),
                BitsN.??
                  (BitsN.bits(pAddr,2,0),
                   BitsN.@@(ReverseEndian (),BitsN.B(0x0,2))))
           val memdoubleword = LoadMemory(CCA,(WORD,(pAddr,(vAddr,DATA))))
           val byte =
             BitsN.??
               (BitsN.bits(vAddr,2,0),
                BitsN.@@(BigEndianCPU (),BitsN.B(0x0,2)))
           val memword =
             BitsN.bits
               (memdoubleword,Nat.+(31,Nat.*(8,BitsN.toNat byte)),
                Nat.*(8,BitsN.toNat byte))
         in
           ( write'GPR
               (if unsigned
                  then BitsN.zeroExtend 64 memword
                else BitsN.signExtend 64 memword,rt)
           ; if link
               then ( LLbit := (Option.SOME true)
                    ; CP0 := (CP0_LLAddr_rupd((!CP0),pAddr))
                    )
             else LLbit := NONE
           )
         end
  end;

fun loadDoubleword (link,(base,(rt,offset))) =
  let
    val vAddr = BitsN.+(BitsN.signExtend 64 offset,GPR base)
  in
    if not((BitsN.bits(vAddr,2,0)) = (BitsN.B(0x0,3)))
      then ( CP0 := (CP0_BadVAddr_rupd((!CP0),vAddr))
           ; SignalException AdEL
           )
    else let
           val (pAddr,CCA) = AddressTranslation(vAddr,(DATA,LOAD))
           val memdoubleword =
             LoadMemory(CCA,(DOUBLEWORD,(pAddr,(vAddr,DATA))))
         in
           ( write'GPR(memdoubleword,rt)
           ; if link
               then ( LLbit := (Option.SOME true)
                    ; CP0 := (CP0_LLAddr_rupd((!CP0),pAddr))
                    )
             else LLbit := NONE
           )
         end
  end;

fun dfn'LB (base,(rt,offset)) = loadByte(base,(rt,(offset,false)));

fun dfn'LBU (base,(rt,offset)) = loadByte(base,(rt,(offset,true)));

fun dfn'LH (base,(rt,offset)) = loadHalf(base,(rt,(offset,false)));

fun dfn'LHU (base,(rt,offset)) = loadHalf(base,(rt,(offset,true)));

fun dfn'LW (base,(rt,offset)) =
  loadWord(false,(base,(rt,(offset,false))));

fun dfn'LWU (base,(rt,offset)) =
  loadWord(false,(base,(rt,(offset,true))));

fun dfn'LL (base,(rt,offset)) = loadWord(true,(base,(rt,(offset,false))));

fun dfn'LD (base,(rt,offset)) = loadDoubleword(false,(base,(rt,offset)));

fun dfn'LLD (base,(rt,offset)) = loadDoubleword(true,(base,(rt,offset)));

fun dfn'LWL (base,(rt,offset)) =
  let
    val vAddr = BitsN.+(BitsN.signExtend 64 offset,GPR base)
    val (pAddr,CCA) = AddressTranslation(vAddr,(DATA,LOAD))
    val pAddr =
      BitsN.@@
        (BitsN.bits(pAddr,Nat.-(PSIZE,1),3),
         BitsN.??
           (BitsN.bits(pAddr,2,0),BitsN.replicate(ReverseEndian (),3)))
    val pAddr =
      if BigEndianMem ()
        then pAddr
      else BitsN.&&(pAddr,BitsN.~(BitsN.B(0x7,64)))
    val byte =
      BitsN.??(BitsN.bits(vAddr,1,0),BitsN.replicate(BigEndianCPU (),2))
    val word = BitsN.??(BitsN.bits(vAddr,2,2),BigEndianCPU ())
    val memdoubleword =
      LoadMemory(CCA,(BitsN.@@(BitsN.B(0x0,1),byte),(pAddr,(vAddr,DATA))))
    val temp =
      case (word,byte) of
         (BitsN.B(0x0,1),BitsN.B(0x0,2)) =>
            BitsN.@@
              (BitsN.bits(memdoubleword,7,0),BitsN.bits(GPR rt,23,0))
       | (BitsN.B(0x0,1),BitsN.B(0x1,2)) =>
            BitsN.@@
              (BitsN.bits(memdoubleword,15,0),BitsN.bits(GPR rt,15,0))
       | (BitsN.B(0x0,1),BitsN.B(0x2,2)) =>
            BitsN.@@
              (BitsN.bits(memdoubleword,23,0),BitsN.bits(GPR rt,7,0))
       | (BitsN.B(0x0,1),BitsN.B(0x3,2)) => BitsN.bits(memdoubleword,31,0)
       | (BitsN.B(0x1,1),BitsN.B(0x0,2)) =>
            BitsN.@@
              (BitsN.bits(memdoubleword,39,32),BitsN.bits(GPR rt,23,0))
       | (BitsN.B(0x1,1),BitsN.B(0x1,2)) =>
            BitsN.@@
              (BitsN.bits(memdoubleword,47,32),BitsN.bits(GPR rt,15,0))
       | (BitsN.B(0x1,1),BitsN.B(0x2,2)) =>
            BitsN.@@
              (BitsN.bits(memdoubleword,55,32),BitsN.bits(GPR rt,7,0))
       | (BitsN.B(0x1,1),BitsN.B(0x3,2)) =>
            BitsN.bits(memdoubleword,63,32)
  in
    ( write'GPR(BitsN.signExtend 64 temp,rt); LLbit := NONE )
  end;

fun dfn'LWR (base,(rt,offset)) =
  let
    val vAddr = BitsN.+(BitsN.signExtend 64 offset,GPR base)
    val (pAddr,CCA) = AddressTranslation(vAddr,(DATA,LOAD))
    val pAddr =
      BitsN.@@
        (BitsN.bits(pAddr,Nat.-(PSIZE,1),3),
         BitsN.??
           (BitsN.bits(pAddr,2,0),BitsN.replicate(ReverseEndian (),3)))
    val pAddr =
      if BigEndianMem ()
        then pAddr
      else BitsN.&&(pAddr,BitsN.~(BitsN.B(0x7,64)))
    val byte =
      BitsN.??(BitsN.bits(vAddr,1,0),BitsN.replicate(BigEndianCPU (),2))
    val word = BitsN.??(BitsN.bits(vAddr,2,2),BigEndianCPU ())
    val memdoubleword =
      LoadMemory
        (CCA,
         (BitsN.-(WORD,BitsN.@@(BitsN.B(0x0,1),byte)),(pAddr,(vAddr,DATA))))
    val temp =
      case (word,byte) of
         (BitsN.B(0x0,1),BitsN.B(0x0,2)) => BitsN.bits(memdoubleword,31,0)
       | (BitsN.B(0x0,1),BitsN.B(0x1,2)) =>
            BitsN.@@
              (BitsN.bits(GPR rt,31,24),BitsN.bits(memdoubleword,31,8))
       | (BitsN.B(0x0,1),BitsN.B(0x2,2)) =>
            BitsN.@@
              (BitsN.bits(GPR rt,31,16),BitsN.bits(memdoubleword,31,16))
       | (BitsN.B(0x0,1),BitsN.B(0x3,2)) =>
            BitsN.@@
              (BitsN.bits(GPR rt,31,8),BitsN.bits(memdoubleword,31,24))
       | (BitsN.B(0x1,1),BitsN.B(0x0,2)) =>
            BitsN.bits(memdoubleword,63,32)
       | (BitsN.B(0x1,1),BitsN.B(0x1,2)) =>
            BitsN.@@
              (BitsN.bits(GPR rt,31,24),BitsN.bits(memdoubleword,63,40))
       | (BitsN.B(0x1,1),BitsN.B(0x2,2)) =>
            BitsN.@@
              (BitsN.bits(GPR rt,31,16),BitsN.bits(memdoubleword,63,48))
       | (BitsN.B(0x1,1),BitsN.B(0x3,2)) =>
            BitsN.@@
              (BitsN.bits(GPR rt,31,8),BitsN.bits(memdoubleword,63,56))
  in
    ( write'GPR(BitsN.signExtend 64 temp,rt); LLbit := NONE )
  end;

fun dfn'LDL (base,(rt,offset)) =
  let
    val vAddr = BitsN.+(BitsN.signExtend 64 offset,GPR base)
    val (pAddr,CCA) = AddressTranslation(vAddr,(DATA,LOAD))
    val pAddr =
      BitsN.@@
        (BitsN.bits(pAddr,Nat.-(PSIZE,1),3),
         BitsN.??
           (BitsN.bits(pAddr,2,0),BitsN.replicate(ReverseEndian (),3)))
    val pAddr =
      if BigEndianMem ()
        then pAddr
      else BitsN.&&(pAddr,BitsN.~(BitsN.B(0x7,64)))
    val byte =
      BitsN.??(BitsN.bits(vAddr,2,0),BitsN.replicate(BigEndianCPU (),3))
    val memdoubleword = LoadMemory(CCA,(byte,(pAddr,(vAddr,DATA))))
  in
    ( write'GPR
        (case byte of
            BitsN.B(0x0,3) =>
               BitsN.@@
                 (BitsN.bits(memdoubleword,7,0),BitsN.bits(GPR rt,55,0))
          | BitsN.B(0x1,3) =>
               BitsN.@@
                 (BitsN.bits(memdoubleword,15,0),BitsN.bits(GPR rt,47,0))
          | BitsN.B(0x2,3) =>
               BitsN.@@
                 (BitsN.bits(memdoubleword,23,0),BitsN.bits(GPR rt,39,0))
          | BitsN.B(0x3,3) =>
               BitsN.@@
                 (BitsN.bits(memdoubleword,31,0),BitsN.bits(GPR rt,31,0))
          | BitsN.B(0x4,3) =>
               BitsN.@@
                 (BitsN.bits(memdoubleword,39,0),BitsN.bits(GPR rt,23,0))
          | BitsN.B(0x5,3) =>
               BitsN.@@
                 (BitsN.bits(memdoubleword,47,0),BitsN.bits(GPR rt,15,0))
          | BitsN.B(0x6,3) =>
               BitsN.@@
                 (BitsN.bits(memdoubleword,55,0),BitsN.bits(GPR rt,7,0))
          | BitsN.B(0x7,3) => BitsN.bits(memdoubleword,63,0)
          | _ => raise General.Bind,rt)
    ; LLbit := NONE
    )
  end;

fun dfn'LDR (base,(rt,offset)) =
  let
    val vAddr = BitsN.+(BitsN.signExtend 64 offset,GPR base)
    val (pAddr,CCA) = AddressTranslation(vAddr,(DATA,LOAD))
    val pAddr =
      BitsN.@@
        (BitsN.bits(pAddr,Nat.-(PSIZE,1),3),
         BitsN.??
           (BitsN.bits(pAddr,2,0),BitsN.replicate(ReverseEndian (),3)))
    val pAddr =
      if BigEndianMem ()
        then pAddr
      else BitsN.&&(pAddr,BitsN.~(BitsN.B(0x7,64)))
    val byte =
      BitsN.??(BitsN.bits(vAddr,2,0),BitsN.replicate(BigEndianCPU (),3))
    val memdoubleword =
      LoadMemory(CCA,(BitsN.-(DOUBLEWORD,byte),(pAddr,(vAddr,DATA))))
  in
    ( write'GPR
        (case byte of
            BitsN.B(0x0,3) => BitsN.bits(memdoubleword,63,0)
          | BitsN.B(0x1,3) =>
               BitsN.@@
                 (BitsN.bits(GPR rt,63,56),BitsN.bits(memdoubleword,63,8))
          | BitsN.B(0x2,3) =>
               BitsN.@@
                 (BitsN.bits(GPR rt,63,48),BitsN.bits(memdoubleword,63,16))
          | BitsN.B(0x3,3) =>
               BitsN.@@
                 (BitsN.bits(GPR rt,63,40),BitsN.bits(memdoubleword,63,24))
          | BitsN.B(0x4,3) =>
               BitsN.@@
                 (BitsN.bits(GPR rt,63,32),BitsN.bits(memdoubleword,63,32))
          | BitsN.B(0x5,3) =>
               BitsN.@@
                 (BitsN.bits(GPR rt,63,24),BitsN.bits(memdoubleword,63,40))
          | BitsN.B(0x6,3) =>
               BitsN.@@
                 (BitsN.bits(GPR rt,63,16),BitsN.bits(memdoubleword,63,48))
          | BitsN.B(0x7,3) =>
               BitsN.@@
                 (BitsN.bits(GPR rt,63,8),BitsN.bits(memdoubleword,63,56))
          | _ => raise General.Bind,rt)
    ; LLbit := NONE
    )
  end;

fun dfn'SB (base,(rt,offset)) =
  let
    val vAddr = BitsN.+(BitsN.signExtend 64 offset,GPR base)
    val (pAddr,CCA) = AddressTranslation(vAddr,(DATA,STORE))
    val pAddr =
      BitsN.@@
        (BitsN.bits(pAddr,Nat.-(PSIZE,1),3),
         BitsN.??
           (BitsN.bits(pAddr,2,0),BitsN.replicate(ReverseEndian (),3)))
    val bytesel =
      BitsN.??(BitsN.bits(vAddr,2,0),BitsN.replicate(BigEndianCPU (),3))
    val datadoubleword = BitsN.<<(GPR rt,Nat.*(8,BitsN.toNat bytesel))
  in
    ( StoreMemory(CCA,(BYTE,(datadoubleword,(pAddr,(vAddr,DATA)))))
    ; LLbit := NONE
    )
  end;

fun dfn'SH (base,(rt,offset)) =
  let
    val vAddr = BitsN.+(BitsN.signExtend 64 offset,GPR base)
  in
    if BitsN.bit(vAddr,0)
      then ( CP0 := (CP0_BadVAddr_rupd((!CP0),vAddr))
           ; SignalException AdES
           )
    else let
           val (pAddr,CCA) = AddressTranslation(vAddr,(DATA,STORE))
           val pAddr =
             BitsN.@@
               (BitsN.bits(pAddr,Nat.-(PSIZE,1),3),
                BitsN.??
                  (BitsN.bits(pAddr,2,0),
                   BitsN.@@
                     (BitsN.replicate(ReverseEndian (),2),BitsN.B(0x0,1))))
           val bytesel =
             BitsN.??
               (BitsN.bits(vAddr,2,0),
                BitsN.@@
                  (BitsN.replicate(BigEndianCPU (),2),BitsN.B(0x0,1)))
           val datadoubleword =
             BitsN.<<(GPR rt,Nat.*(8,BitsN.toNat bytesel))
         in
           ( StoreMemory
               (CCA,(HALFWORD,(datadoubleword,(pAddr,(vAddr,DATA)))))
           ; LLbit := NONE
           )
         end
  end;

fun storeWord (base,(rt,offset)) =
  let
    val vAddr = BitsN.+(BitsN.signExtend 64 offset,GPR base)
  in
    if not((BitsN.bits(vAddr,1,0)) = (BitsN.B(0x0,2)))
      then ( CP0 := (CP0_BadVAddr_rupd((!CP0),vAddr))
           ; SignalException AdES
           )
    else let
           val (pAddr,CCA) = AddressTranslation(vAddr,(DATA,STORE))
           val pAddr =
             BitsN.@@
               (BitsN.bits(pAddr,Nat.-(PSIZE,1),3),
                BitsN.??
                  (BitsN.bits(pAddr,2,0),
                   BitsN.@@(ReverseEndian (),BitsN.B(0x0,2))))
           val bytesel =
             BitsN.??
               (BitsN.bits(vAddr,2,0),
                BitsN.@@(BigEndianCPU (),BitsN.B(0x0,2)))
           val datadoubleword =
             BitsN.<<(GPR rt,Nat.*(8,BitsN.toNat bytesel))
         in
           StoreMemory(CCA,(WORD,(datadoubleword,(pAddr,(vAddr,DATA)))))
         end
  end;

fun storeDoubleword (base,(rt,offset)) =
  let
    val vAddr = BitsN.+(BitsN.signExtend 64 offset,GPR base)
  in
    if not((BitsN.bits(vAddr,2,0)) = (BitsN.B(0x0,3)))
      then ( CP0 := (CP0_BadVAddr_rupd((!CP0),vAddr))
           ; SignalException AdES
           )
    else let
           val (pAddr,CCA) = AddressTranslation(vAddr,(DATA,STORE))
           val datadoubleword = GPR rt
         in
           StoreMemory
             (CCA,(DOUBLEWORD,(datadoubleword,(pAddr,(vAddr,DATA)))))
         end
  end;

fun dfn'SW (base,(rt,offset)) =
  ( storeWord(base,(rt,offset)); LLbit := NONE );

fun dfn'SD (base,(rt,offset)) =
  ( storeDoubleword(base,(rt,offset)); LLbit := NONE );

fun dfn'SC (base,(rt,offset)) =
  case (!LLbit) of
     NONE => raise UNPREDICTABLE ("SC: LLbit not set")
   | Option.SOME false => write'GPR(BitsN.B(0x0,64),rt)
   | Option.SOME true =>
        ( storeWord(base,(rt,offset)); write'GPR(BitsN.B(0x1,64),rt) );

fun dfn'SCD (base,(rt,offset)) =
  case (!LLbit) of
     NONE => raise UNPREDICTABLE ("SCD: LLbit not set")
   | Option.SOME false => write'GPR(BitsN.B(0x0,64),rt)
   | Option.SOME true =>
        ( storeDoubleword(base,(rt,offset))
        ; write'GPR(BitsN.B(0x1,64),rt)
        );

fun dfn'SWL (base,(rt,offset)) =
  let
    val vAddr = BitsN.+(BitsN.signExtend 64 offset,GPR base)
    val (pAddr,CCA) = AddressTranslation(vAddr,(DATA,STORE))
    val pAddr =
      BitsN.@@
        (BitsN.bits(pAddr,Nat.-(PSIZE,1),3),
         BitsN.??
           (BitsN.bits(pAddr,2,0),BitsN.replicate(ReverseEndian (),3)))
    val pAddr =
      if BigEndianMem ()
        then pAddr
      else BitsN.&&(pAddr,BitsN.~(BitsN.B(0x3,64)))
    val byte =
      BitsN.??(BitsN.bits(vAddr,1,0),BitsN.replicate(BigEndianCPU (),2))
    val word = BitsN.??(BitsN.bits(vAddr,2,2),BigEndianCPU ())
    val datadoubleword =
      case byte of
         BitsN.B(0x0,2) =>
            BitsN.fromNat(BitsN.toNat(BitsN.bits(GPR rt,31,24)),64)
       | BitsN.B(0x1,2) =>
            BitsN.fromNat(BitsN.toNat(BitsN.bits(GPR rt,31,16)),64)
       | BitsN.B(0x2,2) =>
            BitsN.fromNat(BitsN.toNat(BitsN.bits(GPR rt,31,8)),64)
       | BitsN.B(0x3,2) =>
            BitsN.fromNat(BitsN.toNat(BitsN.bits(GPR rt,31,0)),64)
       | _ => raise General.Bind
    val datadoubleword =
      if word = (BitsN.B(0x1,1))
        then BitsN.<<(datadoubleword,32)
      else datadoubleword
  in
    StoreMemory
      (CCA,
       (BitsN.fromNat(BitsN.toNat byte,3),
        (datadoubleword,(pAddr,(vAddr,DATA)))))
  end;

fun dfn'SWR (base,(rt,offset)) =
  let
    val vAddr = BitsN.+(BitsN.signExtend 64 offset,GPR base)
    val (pAddr,CCA) = AddressTranslation(vAddr,(DATA,STORE))
    val pAddr =
      BitsN.@@
        (BitsN.bits(pAddr,Nat.-(PSIZE,1),3),
         BitsN.??
           (BitsN.bits(pAddr,2,0),BitsN.replicate(ReverseEndian (),3)))
    val pAddr =
      if BigEndianMem ()
        then BitsN.&&(pAddr,BitsN.~(BitsN.B(0x3,64)))
      else pAddr
    val byte =
      BitsN.??(BitsN.bits(vAddr,1,0),BitsN.replicate(BigEndianCPU (),2))
    val word = BitsN.??(BitsN.bits(vAddr,2,2),BigEndianCPU ())
    val datadoubleword =
      case (word,byte) of
         (BitsN.B(0x0,1),BitsN.B(0x0,2)) =>
            BitsN.fromNat(BitsN.toNat(BitsN.bits(GPR rt,31,0)),64)
       | (BitsN.B(0x0,1),BitsN.B(0x1,2)) =>
            BitsN.<<
              (BitsN.fromNat(BitsN.toNat(BitsN.bits(GPR rt,23,0)),64),8)
       | (BitsN.B(0x0,1),BitsN.B(0x2,2)) =>
            BitsN.<<
              (BitsN.fromNat(BitsN.toNat(BitsN.bits(GPR rt,15,0)),64),16)
       | (BitsN.B(0x0,1),BitsN.B(0x3,2)) =>
            BitsN.<<
              (BitsN.fromNat(BitsN.toNat(BitsN.bits(GPR rt,7,0)),64),24)
       | (BitsN.B(0x1,1),BitsN.B(0x0,2)) =>
            BitsN.<<
              (BitsN.fromNat(BitsN.toNat(BitsN.bits(GPR rt,31,0)),64),32)
       | (BitsN.B(0x1,1),BitsN.B(0x1,2)) =>
            BitsN.<<
              (BitsN.fromNat(BitsN.toNat(BitsN.bits(GPR rt,23,0)),64),40)
       | (BitsN.B(0x1,1),BitsN.B(0x2,2)) =>
            BitsN.<<
              (BitsN.fromNat(BitsN.toNat(BitsN.bits(GPR rt,15,0)),64),48)
       | (BitsN.B(0x1,1),BitsN.B(0x3,2)) =>
            BitsN.<<
              (BitsN.fromNat(BitsN.toNat(BitsN.bits(GPR rt,7,0)),64),56)
  in
    StoreMemory
      (CCA,
       (BitsN.-(WORD,BitsN.fromNat(BitsN.toNat byte,3)),
        (datadoubleword,(pAddr,(vAddr,DATA)))))
  end;

fun dfn'SDL (base,(rt,offset)) =
  let
    val vAddr = BitsN.+(BitsN.signExtend 64 offset,GPR base)
    val (pAddr,CCA) = AddressTranslation(vAddr,(DATA,STORE))
    val pAddr =
      BitsN.@@
        (BitsN.bits(pAddr,Nat.-(PSIZE,1),3),
         BitsN.??
           (BitsN.bits(pAddr,2,0),BitsN.replicate(ReverseEndian (),3)))
    val pAddr =
      if BigEndianMem ()
        then pAddr
      else BitsN.&&(pAddr,BitsN.~(BitsN.B(0x7,64)))
    val byte =
      BitsN.??(BitsN.bits(vAddr,2,0),BitsN.replicate(BigEndianCPU (),3))
    val datadoubleword =
      case byte of
         BitsN.B(0x0,3) =>
            BitsN.fromNat(BitsN.toNat(BitsN.bits(GPR rt,63,56)),64)
       | BitsN.B(0x1,3) =>
            BitsN.fromNat(BitsN.toNat(BitsN.bits(GPR rt,63,48)),64)
       | BitsN.B(0x2,3) =>
            BitsN.fromNat(BitsN.toNat(BitsN.bits(GPR rt,63,40)),64)
       | BitsN.B(0x3,3) =>
            BitsN.fromNat(BitsN.toNat(BitsN.bits(GPR rt,63,32)),64)
       | BitsN.B(0x4,3) =>
            BitsN.fromNat(BitsN.toNat(BitsN.bits(GPR rt,63,24)),64)
       | BitsN.B(0x5,3) =>
            BitsN.fromNat(BitsN.toNat(BitsN.bits(GPR rt,63,16)),64)
       | BitsN.B(0x6,3) =>
            BitsN.fromNat(BitsN.toNat(BitsN.bits(GPR rt,63,8)),64)
       | BitsN.B(0x7,3) => GPR rt
       | _ => raise General.Bind
  in
    StoreMemory(CCA,(byte,(datadoubleword,(pAddr,(vAddr,DATA)))))
  end;

fun dfn'SDR (base,(rt,offset)) =
  let
    val vAddr = BitsN.+(BitsN.signExtend 64 offset,GPR base)
    val (pAddr,CCA) = AddressTranslation(vAddr,(DATA,STORE))
    val pAddr =
      BitsN.@@
        (BitsN.bits(pAddr,Nat.-(PSIZE,1),3),
         BitsN.??
           (BitsN.bits(pAddr,2,0),BitsN.replicate(ReverseEndian (),3)))
    val pAddr =
      if BigEndianMem ()
        then BitsN.&&(pAddr,BitsN.~(BitsN.B(0x7,64)))
      else pAddr
    val byte =
      BitsN.??(BitsN.bits(vAddr,2,0),BitsN.replicate(BigEndianCPU (),3))
    val datadoubleword =
      case byte of
         BitsN.B(0x0,3) => GPR rt
       | BitsN.B(0x1,3) =>
            BitsN.<<
              (BitsN.fromNat(BitsN.toNat(BitsN.bits(GPR rt,55,0)),64),8)
       | BitsN.B(0x2,3) =>
            BitsN.<<
              (BitsN.fromNat(BitsN.toNat(BitsN.bits(GPR rt,47,0)),64),16)
       | BitsN.B(0x3,3) =>
            BitsN.<<
              (BitsN.fromNat(BitsN.toNat(BitsN.bits(GPR rt,39,0)),64),24)
       | BitsN.B(0x4,3) =>
            BitsN.<<
              (BitsN.fromNat(BitsN.toNat(BitsN.bits(GPR rt,31,0)),64),32)
       | BitsN.B(0x5,3) =>
            BitsN.<<
              (BitsN.fromNat(BitsN.toNat(BitsN.bits(GPR rt,23,0)),64),40)
       | BitsN.B(0x6,3) =>
            BitsN.<<
              (BitsN.fromNat(BitsN.toNat(BitsN.bits(GPR rt,15,0)),64),48)
       | BitsN.B(0x7,3) =>
            BitsN.<<
              (BitsN.fromNat(BitsN.toNat(BitsN.bits(GPR rt,7,0)),64),56)
       | _ => raise General.Bind
  in
    StoreMemory
      (CCA,
       (BitsN.-(DOUBLEWORD,byte),(datadoubleword,(pAddr,(vAddr,DATA)))))
  end;

fun dfn'SYNC stype = ();

fun dfn'BREAK () = SignalException Bp;

fun dfn'SYSCALL () = SignalException Sys;

fun dfn'ERET () =
  ( if (#ERL)((#Status) (!CP0))
      then ( PC := (BitsN.-((#ErrorEPC) (!CP0),BitsN.B(0x4,64)))
           ; let
               val x0 = (#Status) (!CP0)
             in
               CP0 :=
               (CP0_Status_rupd((!CP0),StatusRegister_ERL_rupd(x0,false)))
             end
           )
    else ( PC := (BitsN.-((#EPC) (!CP0),BitsN.B(0x4,64)))
         ; let
             val x0 = (#Status) (!CP0)
           in
             CP0 :=
             (CP0_Status_rupd((!CP0),StatusRegister_EXL_rupd(x0,false)))
           end
         )
  ; LLbit := (Option.SOME false)
  );

fun dfn'MTC0 (rt,(rd,sel)) =
  if ((#CU0)((#Status) (!CP0))) orelse (KernelMode ())
    then let val x = (0,(rd,sel)) in write'CPR(GPR rt,x) end
  else SignalException CpU;

fun dfn'DMTC0 (rt,(rd,sel)) =
  if ((#CU0)((#Status) (!CP0))) orelse (KernelMode ())
    then let val x = (0,(rd,sel)) in write'CPR(GPR rt,x) end
  else SignalException CpU;

fun dfn'MFC0 (rt,(rd,sel)) =
  if ((#CU0)((#Status) (!CP0))) orelse (KernelMode ())
    then write'GPR
           (BitsN.signExtend 64 (BitsN.bits(CPR(0,(rd,sel)),31,0)),rt)
  else SignalException CpU;

fun dfn'DMFC0 (rt,(rd,sel)) =
  if ((#CU0)((#Status) (!CP0))) orelse (KernelMode ())
    then write'GPR(CPR(0,(rd,sel)),rt)
  else SignalException CpU;

fun dfn'J instr_index =
  BranchTo :=
  (Option.SOME
     (BitsN.concat[BitsN.bits((!PC),63,28),instr_index,BitsN.B(0x0,2)]));

fun dfn'JAL instr_index =
  ( write'GPR(BitsN.+((!PC),BitsN.B(0x8,64)),BitsN.B(0x1F,5))
  ; BranchTo :=
    (Option.SOME
       (BitsN.concat[BitsN.bits((!PC),63,28),instr_index,BitsN.B(0x0,2)]))
  );

fun dfn'JR rs = BranchTo := (Option.SOME(GPR rs));

fun dfn'JALR (rs,rd) =
  let
    val temp = GPR rs
  in
    ( write'GPR(BitsN.+((!PC),BitsN.B(0x8,64)),rd)
    ; BranchTo := (Option.SOME temp)
    )
  end;

fun dfn'BEQ (rs,(rt,offset)) =
  if (GPR rs) = (GPR rt)
    then BranchTo :=
         (Option.SOME
            (BitsN.+
               (BitsN.+((!PC),BitsN.B(0x4,64)),
                BitsN.<<(BitsN.signExtend 64 offset,2))))
  else ();

fun dfn'BNE (rs,(rt,offset)) =
  if not((GPR rs) = (GPR rt))
    then BranchTo :=
         (Option.SOME
            (BitsN.+
               (BitsN.+((!PC),BitsN.B(0x4,64)),
                BitsN.<<(BitsN.signExtend 64 offset,2))))
  else ();

fun dfn'BLEZ (rs,offset) =
  if BitsN.<=(GPR rs,BitsN.B(0x0,64))
    then BranchTo :=
         (Option.SOME
            (BitsN.+
               (BitsN.+((!PC),BitsN.B(0x4,64)),
                BitsN.<<(BitsN.signExtend 64 offset,2))))
  else ();

fun dfn'BGTZ (rs,offset) =
  if BitsN.>(GPR rs,BitsN.B(0x0,64))
    then BranchTo :=
         (Option.SOME
            (BitsN.+
               (BitsN.+((!PC),BitsN.B(0x4,64)),
                BitsN.<<(BitsN.signExtend 64 offset,2))))
  else ();

fun dfn'BLTZ (rs,offset) =
  if BitsN.<(GPR rs,BitsN.B(0x0,64))
    then BranchTo :=
         (Option.SOME
            (BitsN.+
               (BitsN.+((!PC),BitsN.B(0x4,64)),
                BitsN.<<(BitsN.signExtend 64 offset,2))))
  else ();

fun dfn'BGEZ (rs,offset) =
  if BitsN.>=(GPR rs,BitsN.B(0x0,64))
    then BranchTo :=
         (Option.SOME
            (BitsN.+
               (BitsN.+((!PC),BitsN.B(0x4,64)),
                BitsN.<<(BitsN.signExtend 64 offset,2))))
  else ();

fun dfn'BLTZAL (rs,offset) =
  let
    val temp = GPR rs
  in
    ( write'GPR(BitsN.+((!PC),BitsN.B(0x8,64)),BitsN.B(0x1F,5))
    ; if BitsN.<(temp,BitsN.B(0x0,64))
        then BranchTo :=
             (Option.SOME
                (BitsN.+
                   (BitsN.+((!PC),BitsN.B(0x4,64)),
                    BitsN.<<(BitsN.signExtend 64 offset,2))))
      else ()
    )
  end;

fun dfn'BGEZAL (rs,offset) =
  let
    val temp = GPR rs
  in
    ( write'GPR(BitsN.+((!PC),BitsN.B(0x8,64)),BitsN.B(0x1F,5))
    ; if BitsN.>=(temp,BitsN.B(0x0,64))
        then BranchTo :=
             (Option.SOME
                (BitsN.+
                   (BitsN.+((!PC),BitsN.B(0x4,64)),
                    BitsN.<<(BitsN.signExtend 64 offset,2))))
      else ()
    )
  end;

fun dfn'BEQL (rs,(rt,offset)) =
  if (GPR rs) = (GPR rt)
    then BranchTo :=
         (Option.SOME
            (BitsN.+
               (BitsN.+((!PC),BitsN.B(0x4,64)),
                BitsN.<<(BitsN.signExtend 64 offset,2))))
  else PC := (BitsN.+((!PC),BitsN.B(0x4,64)));

fun dfn'BNEL (rs,(rt,offset)) =
  if not((GPR rs) = (GPR rt))
    then BranchTo :=
         (Option.SOME
            (BitsN.+
               (BitsN.+((!PC),BitsN.B(0x4,64)),
                BitsN.<<(BitsN.signExtend 64 offset,2))))
  else PC := (BitsN.+((!PC),BitsN.B(0x4,64)));

fun dfn'BLEZL (rs,offset) =
  if BitsN.<=(GPR rs,BitsN.B(0x0,64))
    then BranchTo :=
         (Option.SOME
            (BitsN.+
               (BitsN.+((!PC),BitsN.B(0x4,64)),
                BitsN.<<(BitsN.signExtend 64 offset,2))))
  else PC := (BitsN.+((!PC),BitsN.B(0x4,64)));

fun dfn'BGTZL (rs,offset) =
  if BitsN.>(GPR rs,BitsN.B(0x0,64))
    then BranchTo :=
         (Option.SOME
            (BitsN.+
               (BitsN.+((!PC),BitsN.B(0x4,64)),
                BitsN.<<(BitsN.signExtend 64 offset,2))))
  else PC := (BitsN.+((!PC),BitsN.B(0x4,64)));

fun dfn'BLTZL (rs,offset) =
  if BitsN.<(GPR rs,BitsN.B(0x0,64))
    then BranchTo :=
         (Option.SOME
            (BitsN.+
               (BitsN.+((!PC),BitsN.B(0x4,64)),
                BitsN.<<(BitsN.signExtend 64 offset,2))))
  else PC := (BitsN.+((!PC),BitsN.B(0x4,64)));

fun dfn'BGEZL (rs,offset) =
  if BitsN.>=(GPR rs,BitsN.B(0x0,64))
    then BranchTo :=
         (Option.SOME
            (BitsN.+
               (BitsN.+((!PC),BitsN.B(0x4,64)),
                BitsN.<<(BitsN.signExtend 64 offset,2))))
  else PC := (BitsN.+((!PC),BitsN.B(0x4,64)));

fun dfn'BLTZALL (rs,offset) =
  let
    val temp = GPR rs
  in
    ( write'GPR(BitsN.+((!PC),BitsN.B(0x8,64)),BitsN.B(0x1F,5))
    ; if BitsN.<(temp,BitsN.B(0x0,64))
        then BranchTo :=
             (Option.SOME
                (BitsN.+
                   (BitsN.+((!PC),BitsN.B(0x4,64)),
                    BitsN.<<(BitsN.signExtend 64 offset,2))))
      else PC := (BitsN.+((!PC),BitsN.B(0x4,64)))
    )
  end;

fun dfn'BGEZALL (rs,offset) =
  let
    val temp = GPR rs
  in
    ( write'GPR(BitsN.+((!PC),BitsN.B(0x8,64)),BitsN.B(0x1F,5))
    ; if BitsN.>=(temp,BitsN.B(0x0,64))
        then BranchTo :=
             (Option.SOME
                (BitsN.+
                   (BitsN.+((!PC),BitsN.B(0x4,64)),
                    BitsN.<<(BitsN.signExtend 64 offset,2))))
      else PC := (BitsN.+((!PC),BitsN.B(0x4,64)))
    )
  end;

fun dfn'ReservedInstruction () = SignalException RI;

fun Run v0 =
  case v0 of
     BREAK => dfn'BREAK ()
   | ERET => dfn'ERET ()
   | ReservedInstruction => dfn'ReservedInstruction ()
   | SYSCALL => dfn'SYSCALL ()
   | SYNC v127 => dfn'SYNC v127
   | ArithI v1 =>
      (case v1 of
          ADDI v2 => dfn'ADDI v2
        | ADDIU v3 => dfn'ADDIU v3
        | ANDI v4 => dfn'ANDI v4
        | DADDI v5 => dfn'DADDI v5
        | DADDIU v6 => dfn'DADDIU v6
        | LUI v7 => dfn'LUI v7
        | ORI v8 => dfn'ORI v8
        | SLTI v9 => dfn'SLTI v9
        | SLTIU v10 => dfn'SLTIU v10
        | XORI v11 => dfn'XORI v11)
   | ArithR v12 =>
      (case v12 of
          ADD v13 => dfn'ADD v13
        | ADDU v14 => dfn'ADDU v14
        | AND v15 => dfn'AND v15
        | DADD v16 => dfn'DADD v16
        | DADDU v17 => dfn'DADDU v17
        | DSUB v18 => dfn'DSUB v18
        | DSUBU v19 => dfn'DSUBU v19
        | MOVN v20 => dfn'MOVN v20
        | MOVZ v21 => dfn'MOVZ v21
        | NOR v22 => dfn'NOR v22
        | OR v23 => dfn'OR v23
        | SLT v24 => dfn'SLT v24
        | SLTU v25 => dfn'SLTU v25
        | SUB v26 => dfn'SUB v26
        | SUBU v27 => dfn'SUBU v27
        | XOR v28 => dfn'XOR v28)
   | Branch v29 =>
      (case v29 of
          BEQ v30 => dfn'BEQ v30
        | BEQL v31 => dfn'BEQL v31
        | BGEZ v32 => dfn'BGEZ v32
        | BGEZAL v33 => dfn'BGEZAL v33
        | BGEZALL v34 => dfn'BGEZALL v34
        | BGEZL v35 => dfn'BGEZL v35
        | BGTZ v36 => dfn'BGTZ v36
        | BGTZL v37 => dfn'BGTZL v37
        | BLEZ v38 => dfn'BLEZ v38
        | BLEZL v39 => dfn'BLEZL v39
        | BLTZ v40 => dfn'BLTZ v40
        | BLTZAL v41 => dfn'BLTZAL v41
        | BLTZALL v42 => dfn'BLTZALL v42
        | BLTZL v43 => dfn'BLTZL v43
        | BNE v44 => dfn'BNE v44
        | BNEL v45 => dfn'BNEL v45
        | J v46 => dfn'J v46
        | JAL v47 => dfn'JAL v47
        | JALR v48 => dfn'JALR v48
        | JR v49 => dfn'JR v49)
   | CP v50 =>
      (case v50 of
          DMFC0 v51 => dfn'DMFC0 v51
        | DMTC0 v52 => dfn'DMTC0 v52
        | MFC0 v53 => dfn'MFC0 v53
        | MTC0 v54 => dfn'MTC0 v54)
   | Load v55 =>
      (case v55 of
          LB v56 => dfn'LB v56
        | LBU v57 => dfn'LBU v57
        | LD v58 => dfn'LD v58
        | LDL v59 => dfn'LDL v59
        | LDR v60 => dfn'LDR v60
        | LH v61 => dfn'LH v61
        | LHU v62 => dfn'LHU v62
        | LL v63 => dfn'LL v63
        | LLD v64 => dfn'LLD v64
        | LW v65 => dfn'LW v65
        | LWL v66 => dfn'LWL v66
        | LWR v67 => dfn'LWR v67
        | LWU v68 => dfn'LWU v68)
   | MultDiv v69 =>
      (case v69 of
          DDIV v70 => dfn'DDIV v70
        | DDIVU v71 => dfn'DDIVU v71
        | DIV v72 => dfn'DIV v72
        | DIVU v73 => dfn'DIVU v73
        | DMULT v74 => dfn'DMULT v74
        | DMULTU v75 => dfn'DMULTU v75
        | MADD v76 => dfn'MADD v76
        | MADDU v77 => dfn'MADDU v77
        | MFHI v78 => dfn'MFHI v78
        | MFLO v79 => dfn'MFLO v79
        | MSUB v80 => dfn'MSUB v80
        | MSUBU v81 => dfn'MSUBU v81
        | MTHI v82 => dfn'MTHI v82
        | MTLO v83 => dfn'MTLO v83
        | MUL v84 => dfn'MUL v84
        | MULT v85 => dfn'MULT v85
        | MULTU v86 => dfn'MULTU v86)
   | Shift v87 =>
      (case v87 of
          DSLL v88 => dfn'DSLL v88
        | DSLL32 v89 => dfn'DSLL32 v89
        | DSLLV v90 => dfn'DSLLV v90
        | DSRA v91 => dfn'DSRA v91
        | DSRA32 v92 => dfn'DSRA32 v92
        | DSRAV v93 => dfn'DSRAV v93
        | DSRL v94 => dfn'DSRL v94
        | DSRL32 v95 => dfn'DSRL32 v95
        | DSRLV v96 => dfn'DSRLV v96
        | SLL v97 => dfn'SLL v97
        | SLLV v98 => dfn'SLLV v98
        | SRA v99 => dfn'SRA v99
        | SRAV v100 => dfn'SRAV v100
        | SRL v101 => dfn'SRL v101
        | SRLV v102 => dfn'SRLV v102)
   | Store v103 =>
      (case v103 of
          SB v104 => dfn'SB v104
        | SC v105 => dfn'SC v105
        | SCD v106 => dfn'SCD v106
        | SD v107 => dfn'SD v107
        | SDL v108 => dfn'SDL v108
        | SDR v109 => dfn'SDR v109
        | SH v110 => dfn'SH v110
        | SW v111 => dfn'SW v111
        | SWL v112 => dfn'SWL v112
        | SWR v113 => dfn'SWR v113)
   | Trap v114 =>
      (case v114 of
          TEQ v115 => dfn'TEQ v115
        | TEQI v116 => dfn'TEQI v116
        | TGE v117 => dfn'TGE v117
        | TGEI v118 => dfn'TGEI v118
        | TGEIU v119 => dfn'TGEIU v119
        | TGEU v120 => dfn'TGEU v120
        | TLT v121 => dfn'TLT v121
        | TLTI v122 => dfn'TLTI v122
        | TLTIU v123 => dfn'TLTIU v123
        | TLTU v124 => dfn'TLTU v124
        | TNE v125 => dfn'TNE v125
        | TNEI v126 => dfn'TNEI v126);

fun Decode w =
  case boolify'32 w of
     (false,
      (false,
       (false,
        (false,
         (false,
          (false,
           (x'25,
            (x'24,
             (x'23,
              (x'22,
               (x'21,
                (x'20,
                 (x'19,
                  (x'18,
                   (x'17,
                    (x'16,
                     (x'15,
                      (x'14,
                       (x'13,
                        (x'12,
                         (x'11,
                          (x'10,
                           (x'9,
                            (x'8,
                             (x'7,(x'6,(x'5,(x'4,(x'3,(x'2,(x'1,x'0))))))))))))))))))))))))))))))) =>
      (case boolify'26
         (BitsN.fromBitstring
            ([x'25,x'24,x'23,x'22,x'21,x'20,x'19,x'18,x'17,x'16,x'15,x'14,
              x'13,x'12,x'11,x'10,x'9,x'8,x'7,x'6,x'5,x'4,x'3,x'2,x'1,x'0],
             26)) of
          (false,
           (false,
            (false,
             (false,
              (false,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (rd'4,
                     (rd'3,
                      (rd'2,
                       (rd'1,
                        (rd'0,
                         (imm5'4,
                          (imm5'3,
                           (imm5'2,
                            (imm5'1,
                             (imm5'0,
                              (false,(false,(false,(false,(false,false))))))))))))))))))))))))) =>
           Shift
             (SLL(BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5),
                  (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
                   BitsN.fromBitstring
                     ([imm5'4,imm5'3,imm5'2,imm5'1,imm5'0],5))))
        | (false,
           (false,
            (false,
             (false,
              (false,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (rd'4,
                     (rd'3,
                      (rd'2,
                       (rd'1,
                        (rd'0,
                         (imm5'4,
                          (imm5'3,
                           (imm5'2,
                            (imm5'1,
                             (imm5'0,
                              (false,(false,(false,(false,(true,false))))))))))))))))))))))))) =>
           Shift
             (SRL(BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5),
                  (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
                   BitsN.fromBitstring
                     ([imm5'4,imm5'3,imm5'2,imm5'1,imm5'0],5))))
        | (false,
           (false,
            (false,
             (false,
              (false,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (rd'4,
                     (rd'3,
                      (rd'2,
                       (rd'1,
                        (rd'0,
                         (imm5'4,
                          (imm5'3,
                           (imm5'2,
                            (imm5'1,
                             (imm5'0,
                              (false,(false,(false,(false,(true,true))))))))))))))))))))))))) =>
           Shift
             (SRA(BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5),
                  (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
                   BitsN.fromBitstring
                     ([imm5'4,imm5'3,imm5'2,imm5'1,imm5'0],5))))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (rd'4,
                     (rd'3,
                      (rd'2,
                       (rd'1,
                        (rd'0,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (false,(false,(false,(true,(false,false))))))))))))))))))))))))) =>
           Shift
             (SLLV
                (BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                 (BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5),
                  BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5))))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (rd'4,
                     (rd'3,
                      (rd'2,
                       (rd'1,
                        (rd'0,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (false,(false,(false,(true,(true,false))))))))))))))))))))))))) =>
           Shift
             (SRLV
                (BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                 (BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5),
                  BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5))))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (rd'4,
                     (rd'3,
                      (rd'2,
                       (rd'1,
                        (rd'0,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (false,(false,(false,(true,(true,true))))))))))))))))))))))))) =>
           Shift
             (SRAV
                (BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                 (BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5),
                  BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5))))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (false,
                (false,
                 (false,
                  (false,
                   (false,
                    (false,
                     (false,
                      (false,
                       (false,
                        (false,
                         (hint'4,
                          (hint'3,
                           (hint'2,
                            (hint'1,
                             (hint'0,
                              (false,(false,(true,(false,(false,false))))))))))))))))))))))))) =>
           Branch(JR(BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5)))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (false,
                (false,
                 (false,
                  (false,
                   (false,
                    (rd'4,
                     (rd'3,
                      (rd'2,
                       (rd'1,
                        (rd'0,
                         (hint'4,
                          (hint'3,
                           (hint'2,
                            (hint'1,
                             (hint'0,
                              (false,(false,(true,(false,(false,true))))))))))))))))))))))))) =>
           Branch
             (JALR
                (BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                 BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5)))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (rd'4,
                     (rd'3,
                      (rd'2,
                       (rd'1,
                        (rd'0,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (false,(false,(true,(false,(true,false))))))))))))))))))))))))) =>
           ArithR
             (MOVZ
                (BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                 (BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5),
                  BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5))))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (rd'4,
                     (rd'3,
                      (rd'2,
                       (rd'1,
                        (rd'0,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (false,(false,(true,(false,(true,true))))))))))))))))))))))))) =>
           ArithR
             (MOVN
                (BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                 (BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5),
                  BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5))))
        | (false,
           (false,
            (false,
             (false,
              (false,
               (code'14,
                (code'13,
                 (code'12,
                  (code'11,
                   (code'10,
                    (code'9,
                     (code'8,
                      (code'7,
                       (code'6,
                        (code'5,
                         (code'4,
                          (code'3,
                           (code'2,
                            (code'1,
                             (code'0,
                              (false,(false,(true,(true,(false,false))))))))))))))))))))))))) =>
           SYSCALL
        | (false,
           (false,
            (false,
             (false,
              (false,
               (code'14,
                (code'13,
                 (code'12,
                  (code'11,
                   (code'10,
                    (code'9,
                     (code'8,
                      (code'7,
                       (code'6,
                        (code'5,
                         (code'4,
                          (code'3,
                           (code'2,
                            (code'1,
                             (code'0,
                              (false,(false,(true,(true,(false,true))))))))))))))))))))))))) =>
           BREAK
        | (false,
           (false,
            (false,
             (false,
              (false,
               (false,
                (false,
                 (false,
                  (false,
                   (false,
                    (false,
                     (false,
                      (false,
                       (false,
                        (false,
                         (imm5'4,
                          (imm5'3,
                           (imm5'2,
                            (imm5'1,
                             (imm5'0,
                              (false,(false,(true,(true,(true,true))))))))))))))))))))))))) =>
           SYNC
             (BitsN.fromBitstring([imm5'4,imm5'3,imm5'2,imm5'1,imm5'0],5))
        | (false,
           (false,
            (false,
             (false,
              (false,
               (false,
                (false,
                 (false,
                  (false,
                   (false,
                    (rd'4,
                     (rd'3,
                      (rd'2,
                       (rd'1,
                        (rd'0,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (false,(true,(false,(false,(false,false))))))))))))))))))))))))) =>
           MultDiv
             (MFHI(BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5)))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (false,
                (false,
                 (false,
                  (false,
                   (false,
                    (false,
                     (false,
                      (false,
                       (false,
                        (false,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (false,(true,(false,(false,(false,true))))))))))))))))))))))))) =>
           MultDiv
             (MTHI(BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5)))
        | (false,
           (false,
            (false,
             (false,
              (false,
               (false,
                (false,
                 (false,
                  (false,
                   (false,
                    (rd'4,
                     (rd'3,
                      (rd'2,
                       (rd'1,
                        (rd'0,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (false,(true,(false,(false,(true,false))))))))))))))))))))))))) =>
           MultDiv
             (MFLO(BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5)))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (false,
                (false,
                 (false,
                  (false,
                   (false,
                    (false,
                     (false,
                      (false,
                       (false,
                        (false,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (false,(true,(false,(false,(true,true))))))))))))))))))))))))) =>
           MultDiv
             (MTLO(BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5)))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (rd'4,
                     (rd'3,
                      (rd'2,
                       (rd'1,
                        (rd'0,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (false,(true,(false,(true,(false,false))))))))))))))))))))))))) =>
           Shift
             (DSLLV
                (BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                 (BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5),
                  BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5))))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (rd'4,
                     (rd'3,
                      (rd'2,
                       (rd'1,
                        (rd'0,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (false,(true,(false,(true,(true,false))))))))))))))))))))))))) =>
           Shift
             (DSRLV
                (BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                 (BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5),
                  BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5))))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (rd'4,
                     (rd'3,
                      (rd'2,
                       (rd'1,
                        (rd'0,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (false,(true,(false,(true,(true,true))))))))))))))))))))))))) =>
           Shift
             (DSRAV
                (BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                 (BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5),
                  BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5))))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (false,
                     (false,
                      (false,
                       (false,
                        (false,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (false,(true,(true,(false,(false,false))))))))))))))))))))))))) =>
           MultDiv
             (MULT
                (BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                 BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5)))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (false,
                     (false,
                      (false,
                       (false,
                        (false,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (false,(true,(true,(false,(false,true))))))))))))))))))))))))) =>
           MultDiv
             (MULTU
                (BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                 BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5)))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (false,
                     (false,
                      (false,
                       (false,
                        (false,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (false,(true,(true,(false,(true,false))))))))))))))))))))))))) =>
           MultDiv
             (DIV(BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                  BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5)))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (false,
                     (false,
                      (false,
                       (false,
                        (false,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (false,(true,(true,(false,(true,true))))))))))))))))))))))))) =>
           MultDiv
             (DIVU
                (BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                 BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5)))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (false,
                     (false,
                      (false,
                       (false,
                        (false,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (false,(true,(true,(true,(false,false))))))))))))))))))))))))) =>
           MultDiv
             (DMULT
                (BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                 BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5)))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (false,
                     (false,
                      (false,
                       (false,
                        (false,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (false,(true,(true,(true,(false,true))))))))))))))))))))))))) =>
           MultDiv
             (DMULTU
                (BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                 BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5)))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (false,
                     (false,
                      (false,
                       (false,
                        (false,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (false,(true,(true,(true,(true,false))))))))))))))))))))))))) =>
           MultDiv
             (DDIV
                (BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                 BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5)))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (false,
                     (false,
                      (false,
                       (false,
                        (false,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (false,(true,(true,(true,(true,true))))))))))))))))))))))))) =>
           MultDiv
             (DDIVU
                (BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                 BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5)))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (rd'4,
                     (rd'3,
                      (rd'2,
                       (rd'1,
                        (rd'0,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (true,(false,(false,(false,(false,false))))))))))))))))))))))))) =>
           ArithR
             (ADD(BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                  (BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5),
                   BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5))))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (rd'4,
                     (rd'3,
                      (rd'2,
                       (rd'1,
                        (rd'0,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (true,(false,(false,(false,(false,true))))))))))))))))))))))))) =>
           ArithR
             (ADDU
                (BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                 (BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5),
                  BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5))))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (rd'4,
                     (rd'3,
                      (rd'2,
                       (rd'1,
                        (rd'0,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (true,(false,(false,(false,(true,false))))))))))))))))))))))))) =>
           ArithR
             (SUB(BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                  (BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5),
                   BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5))))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (rd'4,
                     (rd'3,
                      (rd'2,
                       (rd'1,
                        (rd'0,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (true,(false,(false,(false,(true,true))))))))))))))))))))))))) =>
           ArithR
             (SUBU
                (BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                 (BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5),
                  BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5))))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (rd'4,
                     (rd'3,
                      (rd'2,
                       (rd'1,
                        (rd'0,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (true,(false,(false,(true,(false,false))))))))))))))))))))))))) =>
           ArithR
             (AND(BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                  (BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5),
                   BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5))))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (rd'4,
                     (rd'3,
                      (rd'2,
                       (rd'1,
                        (rd'0,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (true,(false,(false,(true,(false,true))))))))))))))))))))))))) =>
           ArithR
             (OR(BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                 (BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5),
                  BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5))))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (rd'4,
                     (rd'3,
                      (rd'2,
                       (rd'1,
                        (rd'0,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (true,(false,(false,(true,(true,false))))))))))))))))))))))))) =>
           ArithR
             (XOR(BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                  (BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5),
                   BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5))))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (rd'4,
                     (rd'3,
                      (rd'2,
                       (rd'1,
                        (rd'0,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (true,(false,(false,(true,(true,true))))))))))))))))))))))))) =>
           ArithR
             (NOR(BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                  (BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5),
                   BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5))))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (rd'4,
                     (rd'3,
                      (rd'2,
                       (rd'1,
                        (rd'0,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (true,(false,(true,(false,(true,false))))))))))))))))))))))))) =>
           ArithR
             (SLT(BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                  (BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5),
                   BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5))))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (rd'4,
                     (rd'3,
                      (rd'2,
                       (rd'1,
                        (rd'0,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (true,(false,(true,(false,(true,true))))))))))))))))))))))))) =>
           ArithR
             (SLTU
                (BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                 (BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5),
                  BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5))))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (rd'4,
                     (rd'3,
                      (rd'2,
                       (rd'1,
                        (rd'0,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (true,(false,(true,(true,(false,false))))))))))))))))))))))))) =>
           ArithR
             (DADD
                (BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                 (BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5),
                  BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5))))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (rd'4,
                     (rd'3,
                      (rd'2,
                       (rd'1,
                        (rd'0,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (true,(false,(true,(true,(false,true))))))))))))))))))))))))) =>
           ArithR
             (DADDU
                (BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                 (BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5),
                  BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5))))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (rd'4,
                     (rd'3,
                      (rd'2,
                       (rd'1,
                        (rd'0,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (true,(false,(true,(true,(true,false))))))))))))))))))))))))) =>
           ArithR
             (DSUB
                (BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                 (BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5),
                  BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5))))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (rd'4,
                     (rd'3,
                      (rd'2,
                       (rd'1,
                        (rd'0,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (true,(false,(true,(true,(true,true))))))))))))))))))))))))) =>
           ArithR
             (DSUBU
                (BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                 (BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5),
                  BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5))))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (code'9,
                     (code'8,
                      (code'7,
                       (code'6,
                        (code'5,
                         (code'4,
                          (code'3,
                           (code'2,
                            (code'1,
                             (code'0,
                              (true,(true,(false,(false,(false,false))))))))))))))))))))))))) =>
           Trap
             (TGE(BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                  BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5)))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (code'9,
                     (code'8,
                      (code'7,
                       (code'6,
                        (code'5,
                         (code'4,
                          (code'3,
                           (code'2,
                            (code'1,
                             (code'0,
                              (true,(true,(false,(false,(false,true))))))))))))))))))))))))) =>
           Trap
             (TGEU
                (BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                 BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5)))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (code'9,
                     (code'8,
                      (code'7,
                       (code'6,
                        (code'5,
                         (code'4,
                          (code'3,
                           (code'2,
                            (code'1,
                             (code'0,
                              (true,(true,(false,(false,(true,false))))))))))))))))))))))))) =>
           Trap
             (TLT(BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                  BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5)))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (code'9,
                     (code'8,
                      (code'7,
                       (code'6,
                        (code'5,
                         (code'4,
                          (code'3,
                           (code'2,
                            (code'1,
                             (code'0,
                              (true,(true,(false,(false,(true,true))))))))))))))))))))))))) =>
           Trap
             (TLTU
                (BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                 BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5)))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (code'9,
                     (code'8,
                      (code'7,
                       (code'6,
                        (code'5,
                         (code'4,
                          (code'3,
                           (code'2,
                            (code'1,
                             (code'0,
                              (true,(true,(false,(true,(false,false))))))))))))))))))))))))) =>
           Trap
             (TEQ(BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                  BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5)))
        | (rs'4,
           (rs'3,
            (rs'2,
             (rs'1,
              (rs'0,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (code'9,
                     (code'8,
                      (code'7,
                       (code'6,
                        (code'5,
                         (code'4,
                          (code'3,
                           (code'2,
                            (code'1,
                             (code'0,
                              (true,(true,(false,(true,(true,false))))))))))))))))))))))))) =>
           Trap
             (TNE(BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
                  BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5)))
        | (false,
           (false,
            (false,
             (false,
              (false,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (rd'4,
                     (rd'3,
                      (rd'2,
                       (rd'1,
                        (rd'0,
                         (imm5'4,
                          (imm5'3,
                           (imm5'2,
                            (imm5'1,
                             (imm5'0,
                              (true,(true,(true,(false,(false,false))))))))))))))))))))))))) =>
           Shift
             (DSLL
                (BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5),
                 (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
                  BitsN.fromBitstring
                    ([imm5'4,imm5'3,imm5'2,imm5'1,imm5'0],5))))
        | (false,
           (false,
            (false,
             (false,
              (false,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (rd'4,
                     (rd'3,
                      (rd'2,
                       (rd'1,
                        (rd'0,
                         (imm5'4,
                          (imm5'3,
                           (imm5'2,
                            (imm5'1,
                             (imm5'0,
                              (true,(true,(true,(false,(true,false))))))))))))))))))))))))) =>
           Shift
             (DSRL
                (BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5),
                 (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
                  BitsN.fromBitstring
                    ([imm5'4,imm5'3,imm5'2,imm5'1,imm5'0],5))))
        | (false,
           (false,
            (false,
             (false,
              (false,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (rd'4,
                     (rd'3,
                      (rd'2,
                       (rd'1,
                        (rd'0,
                         (imm5'4,
                          (imm5'3,
                           (imm5'2,
                            (imm5'1,
                             (imm5'0,
                              (true,(true,(true,(false,(true,true))))))))))))))))))))))))) =>
           Shift
             (DSRA
                (BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5),
                 (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
                  BitsN.fromBitstring
                    ([imm5'4,imm5'3,imm5'2,imm5'1,imm5'0],5))))
        | (false,
           (false,
            (false,
             (false,
              (false,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (rd'4,
                     (rd'3,
                      (rd'2,
                       (rd'1,
                        (rd'0,
                         (imm5'4,
                          (imm5'3,
                           (imm5'2,
                            (imm5'1,
                             (imm5'0,
                              (true,(true,(true,(true,(false,false))))))))))))))))))))))))) =>
           Shift
             (DSLL32
                (BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5),
                 (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
                  BitsN.fromBitstring
                    ([imm5'4,imm5'3,imm5'2,imm5'1,imm5'0],5))))
        | (false,
           (false,
            (false,
             (false,
              (false,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (rd'4,
                     (rd'3,
                      (rd'2,
                       (rd'1,
                        (rd'0,
                         (imm5'4,
                          (imm5'3,
                           (imm5'2,
                            (imm5'1,
                             (imm5'0,
                              (true,(true,(true,(true,(true,false))))))))))))))))))))))))) =>
           Shift
             (DSRL32
                (BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5),
                 (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
                  BitsN.fromBitstring
                    ([imm5'4,imm5'3,imm5'2,imm5'1,imm5'0],5))))
        | (false,
           (false,
            (false,
             (false,
              (false,
               (rt'4,
                (rt'3,
                 (rt'2,
                  (rt'1,
                   (rt'0,
                    (rd'4,
                     (rd'3,
                      (rd'2,
                       (rd'1,
                        (rd'0,
                         (imm5'4,
                          (imm5'3,
                           (imm5'2,
                            (imm5'1,
                             (imm5'0,
                              (true,(true,(true,(true,(true,true))))))))))))))))))))))))) =>
           Shift
             (DSRA32
                (BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5),
                 (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
                  BitsN.fromBitstring
                    ([imm5'4,imm5'3,imm5'2,imm5'1,imm5'0],5))))
        | (_,
           (_,
            (_,
             (_,
              (_,
               (_,
                (_,
                 (_,
                  (_,
                   (_,
                    (_,
                     (_,
                      (_,(_,(_,(_,(_,(_,(_,(_,(_,(_,(_,(_,(_,_))))))))))))))))))))))))) =>
           ReservedInstruction)
   | (false,
      (false,
       (false,
        (false,
         (false,
          (true,
           (rs'4,
            (rs'3,
             (rs'2,
              (rs'1,
               (rs'0,
                (function'4,
                 (function'3,
                  (function'2,
                   (function'1,
                    (function'0,
                     (immediate'15,
                      (immediate'14,
                       (immediate'13,
                        (immediate'12,
                         (immediate'11,
                          (immediate'10,
                           (immediate'9,
                            (immediate'8,
                             (immediate'7,
                              (immediate'6,
                               (immediate'5,
                                (immediate'4,
                                 (immediate'3,
                                  (immediate'2,(immediate'1,immediate'0))))))))))))))))))))))))))))))) =>
      let
        val immediate =
          BitsN.fromBitstring
            ([immediate'15,immediate'14,immediate'13,immediate'12,
              immediate'11,immediate'10,immediate'9,immediate'8,
              immediate'7,immediate'6,immediate'5,immediate'4,immediate'3,
              immediate'2,immediate'1,immediate'0],16)
        val rs = BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5)
      in
        case boolify'5
          (BitsN.fromBitstring
             ([function'4,function'3,function'2,function'1,function'0],5)) of
           (false,(false,(false,(false,false)))) =>
              Branch(BLTZ(rs,immediate))
         | (false,(false,(false,(false,true)))) =>
              Branch(BGEZ(rs,immediate))
         | (false,(false,(false,(true,false)))) =>
              Branch(BLTZL(rs,immediate))
         | (false,(false,(false,(true,true)))) =>
              Branch(BGEZL(rs,immediate))
         | (false,(true,(false,(false,false)))) =>
              Trap(TGEI(rs,immediate))
         | (false,(true,(false,(false,true)))) =>
              Trap(TGEIU(rs,immediate))
         | (false,(true,(false,(true,false)))) => Trap(TLTI(rs,immediate))
         | (false,(true,(false,(true,true)))) => Trap(TLTIU(rs,immediate))
         | (false,(true,(true,(false,false)))) => Trap(TEQI(rs,immediate))
         | (false,(true,(true,(true,false)))) => Trap(TNEI(rs,immediate))
         | (true,(false,(false,(false,false)))) =>
              Branch(BLTZAL(rs,immediate))
         | (true,(false,(false,(false,true)))) =>
              Branch(BGEZAL(rs,immediate))
         | (true,(false,(false,(true,false)))) =>
              Branch(BLTZALL(rs,immediate))
         | (true,(false,(false,(true,true)))) =>
              Branch(BGEZALL(rs,immediate))
         | (_,(_,(_,(_,_)))) => ReservedInstruction
      end
   | (false,
      (false,
       (false,
        (false,
         (true,
          (false,
           (immediate'25,
            (immediate'24,
             (immediate'23,
              (immediate'22,
               (immediate'21,
                (immediate'20,
                 (immediate'19,
                  (immediate'18,
                   (immediate'17,
                    (immediate'16,
                     (immediate'15,
                      (immediate'14,
                       (immediate'13,
                        (immediate'12,
                         (immediate'11,
                          (immediate'10,
                           (immediate'9,
                            (immediate'8,
                             (immediate'7,
                              (immediate'6,
                               (immediate'5,
                                (immediate'4,
                                 (immediate'3,
                                  (immediate'2,(immediate'1,immediate'0))))))))))))))))))))))))))))))) =>
      Branch
        (J(BitsN.fromBitstring
             ([immediate'25,immediate'24,immediate'23,immediate'22,
               immediate'21,immediate'20,immediate'19,immediate'18,
               immediate'17,immediate'16,immediate'15,immediate'14,
               immediate'13,immediate'12,immediate'11,immediate'10,
               immediate'9,immediate'8,immediate'7,immediate'6,
               immediate'5,immediate'4,immediate'3,immediate'2,
               immediate'1,immediate'0],26)))
   | (false,
      (false,
       (false,
        (false,
         (true,
          (true,
           (immediate'25,
            (immediate'24,
             (immediate'23,
              (immediate'22,
               (immediate'21,
                (immediate'20,
                 (immediate'19,
                  (immediate'18,
                   (immediate'17,
                    (immediate'16,
                     (immediate'15,
                      (immediate'14,
                       (immediate'13,
                        (immediate'12,
                         (immediate'11,
                          (immediate'10,
                           (immediate'9,
                            (immediate'8,
                             (immediate'7,
                              (immediate'6,
                               (immediate'5,
                                (immediate'4,
                                 (immediate'3,
                                  (immediate'2,(immediate'1,immediate'0))))))))))))))))))))))))))))))) =>
      Branch
        (JAL(BitsN.fromBitstring
               ([immediate'25,immediate'24,immediate'23,immediate'22,
                 immediate'21,immediate'20,immediate'19,immediate'18,
                 immediate'17,immediate'16,immediate'15,immediate'14,
                 immediate'13,immediate'12,immediate'11,immediate'10,
                 immediate'9,immediate'8,immediate'7,immediate'6,
                 immediate'5,immediate'4,immediate'3,immediate'2,
                 immediate'1,immediate'0],26)))
   | (false,
        (true,
         (false,
          (false,
           (false,
            (false,
             (true,
              (false,
               (false,
                (false,
                 (false,
                  (false,
                   (false,
                    (false,
                     (false,
                      (false,
                       (false,
                        (false,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (false,
                               (false,
                                (false,
                                 (false,
                                  (true,(true,(false,(false,false))))))))))))))))))))))))))))))) =>
        ERET
   | (false,
      (true,
       (false,
        (false,
         (false,
          (false,
           (function'4,
            (function'3,
             (function'2,
              (function'1,
               (function'0,
                (rt'4,
                 (rt'3,
                  (rt'2,
                   (rt'1,
                    (rt'0,
                     (rd'4,
                      (rd'3,
                       (rd'2,
                        (rd'1,
                         (rd'0,
                          (false,
                           (false,
                            (false,
                             (false,
                              (false,
                               (false,
                                (false,(false,(sel'2,(sel'1,sel'0))))))))))))))))))))))))))))))) =>
      let
        val sel = BitsN.fromBitstring([sel'2,sel'1,sel'0],3)
        val rd = BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5)
        val rt = BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5)
      in
        case boolify'5
          (BitsN.fromBitstring
             ([function'4,function'3,function'2,function'1,function'0],5)) of
           (false,(false,(false,(false,false)))) => CP(MFC0(rt,(rd,sel)))
         | (false,(false,(false,(false,true)))) => CP(DMFC0(rt,(rd,sel)))
         | (false,(false,(true,(false,false)))) => CP(MTC0(rt,(rd,sel)))
         | (false,(false,(true,(false,true)))) => CP(DMTC0(rt,(rd,sel)))
         | (_,(_,(_,(_,_)))) => ReservedInstruction
      end
   | (false,
      (false,
       (false,
        (true,
         (true,
          (false,
           (rs'4,
            (rs'3,
             (rs'2,
              (rs'1,
               (rs'0,
                (false,
                 (false,
                  (false,
                   (false,
                    (false,
                     (immediate'15,
                      (immediate'14,
                       (immediate'13,
                        (immediate'12,
                         (immediate'11,
                          (immediate'10,
                           (immediate'9,
                            (immediate'8,
                             (immediate'7,
                              (immediate'6,
                               (immediate'5,
                                (immediate'4,
                                 (immediate'3,
                                  (immediate'2,(immediate'1,immediate'0))))))))))))))))))))))))))))))) =>
      Branch
        (BLEZ
           (BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
            BitsN.fromBitstring
              ([immediate'15,immediate'14,immediate'13,immediate'12,
                immediate'11,immediate'10,immediate'9,immediate'8,
                immediate'7,immediate'6,immediate'5,immediate'4,
                immediate'3,immediate'2,immediate'1,immediate'0],16)))
   | (false,
      (false,
       (false,
        (true,
         (true,
          (true,
           (rs'4,
            (rs'3,
             (rs'2,
              (rs'1,
               (rs'0,
                (false,
                 (false,
                  (false,
                   (false,
                    (false,
                     (immediate'15,
                      (immediate'14,
                       (immediate'13,
                        (immediate'12,
                         (immediate'11,
                          (immediate'10,
                           (immediate'9,
                            (immediate'8,
                             (immediate'7,
                              (immediate'6,
                               (immediate'5,
                                (immediate'4,
                                 (immediate'3,
                                  (immediate'2,(immediate'1,immediate'0))))))))))))))))))))))))))))))) =>
      Branch
        (BGTZ
           (BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
            BitsN.fromBitstring
              ([immediate'15,immediate'14,immediate'13,immediate'12,
                immediate'11,immediate'10,immediate'9,immediate'8,
                immediate'7,immediate'6,immediate'5,immediate'4,
                immediate'3,immediate'2,immediate'1,immediate'0],16)))
   | (false,
      (false,
       (true,
        (true,
         (true,
          (true,
           (false,
            (false,
             (false,
              (false,
               (false,
                (rt'4,
                 (rt'3,
                  (rt'2,
                   (rt'1,
                    (rt'0,
                     (immediate'15,
                      (immediate'14,
                       (immediate'13,
                        (immediate'12,
                         (immediate'11,
                          (immediate'10,
                           (immediate'9,
                            (immediate'8,
                             (immediate'7,
                              (immediate'6,
                               (immediate'5,
                                (immediate'4,
                                 (immediate'3,
                                  (immediate'2,(immediate'1,immediate'0))))))))))))))))))))))))))))))) =>
      ArithI
        (LUI(BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5),
             BitsN.fromBitstring
               ([immediate'15,immediate'14,immediate'13,immediate'12,
                 immediate'11,immediate'10,immediate'9,immediate'8,
                 immediate'7,immediate'6,immediate'5,immediate'4,
                 immediate'3,immediate'2,immediate'1,immediate'0],16)))
   | (false,
      (true,
       (false,
        (true,
         (true,
          (false,
           (rs'4,
            (rs'3,
             (rs'2,
              (rs'1,
               (rs'0,
                (false,
                 (false,
                  (false,
                   (false,
                    (false,
                     (immediate'15,
                      (immediate'14,
                       (immediate'13,
                        (immediate'12,
                         (immediate'11,
                          (immediate'10,
                           (immediate'9,
                            (immediate'8,
                             (immediate'7,
                              (immediate'6,
                               (immediate'5,
                                (immediate'4,
                                 (immediate'3,
                                  (immediate'2,(immediate'1,immediate'0))))))))))))))))))))))))))))))) =>
      Branch
        (BLEZL
           (BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
            BitsN.fromBitstring
              ([immediate'15,immediate'14,immediate'13,immediate'12,
                immediate'11,immediate'10,immediate'9,immediate'8,
                immediate'7,immediate'6,immediate'5,immediate'4,
                immediate'3,immediate'2,immediate'1,immediate'0],16)))
   | (false,
      (true,
       (false,
        (true,
         (true,
          (true,
           (rs'4,
            (rs'3,
             (rs'2,
              (rs'1,
               (rs'0,
                (false,
                 (false,
                  (false,
                   (false,
                    (false,
                     (immediate'15,
                      (immediate'14,
                       (immediate'13,
                        (immediate'12,
                         (immediate'11,
                          (immediate'10,
                           (immediate'9,
                            (immediate'8,
                             (immediate'7,
                              (immediate'6,
                               (immediate'5,
                                (immediate'4,
                                 (immediate'3,
                                  (immediate'2,(immediate'1,immediate'0))))))))))))))))))))))))))))))) =>
      Branch
        (BGTZL
           (BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
            BitsN.fromBitstring
              ([immediate'15,immediate'14,immediate'13,immediate'12,
                immediate'11,immediate'10,immediate'9,immediate'8,
                immediate'7,immediate'6,immediate'5,immediate'4,
                immediate'3,immediate'2,immediate'1,immediate'0],16)))
   | (false,
      (true,
       (true,
        (true,
         (false,
          (false,
           (rs'4,
            (rs'3,
             (rs'2,
              (rs'1,
               (rs'0,
                (rt'4,
                 (rt'3,
                  (rt'2,
                   (rt'1,
                    (rt'0,
                     (false,
                      (false,
                       (false,
                        (false,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (false,
                               (false,
                                (false,(false,(false,(false,false))))))))))))))))))))))))))))))) =>
      MultDiv
        (MADD
           (BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
            BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5)))
   | (false,
      (true,
       (true,
        (true,
         (false,
          (false,
           (rs'4,
            (rs'3,
             (rs'2,
              (rs'1,
               (rs'0,
                (rt'4,
                 (rt'3,
                  (rt'2,
                   (rt'1,
                    (rt'0,
                     (false,
                      (false,
                       (false,
                        (false,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (false,
                               (false,(false,(false,(false,(false,true))))))))))))))))))))))))))))))) =>
      MultDiv
        (MADDU
           (BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
            BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5)))
   | (false,
      (true,
       (true,
        (true,
         (false,
          (false,
           (rs'4,
            (rs'3,
             (rs'2,
              (rs'1,
               (rs'0,
                (rt'4,
                 (rt'3,
                  (rt'2,
                   (rt'1,
                    (rt'0,
                     (false,
                      (false,
                       (false,
                        (false,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (false,
                               (false,(false,(false,(true,(false,false))))))))))))))))))))))))))))))) =>
      MultDiv
        (MSUB
           (BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
            BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5)))
   | (false,
      (true,
       (true,
        (true,
         (false,
          (false,
           (rs'4,
            (rs'3,
             (rs'2,
              (rs'1,
               (rs'0,
                (rt'4,
                 (rt'3,
                  (rt'2,
                   (rt'1,
                    (rt'0,
                     (false,
                      (false,
                       (false,
                        (false,
                         (false,
                          (false,
                           (false,
                            (false,
                             (false,
                              (false,
                               (false,(false,(false,(true,(false,true))))))))))))))))))))))))))))))) =>
      MultDiv
        (MSUBU
           (BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
            BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5)))
   | (false,
      (true,
       (true,
        (true,
         (false,
          (false,
           (rs'4,
            (rs'3,
             (rs'2,
              (rs'1,
               (rs'0,
                (rt'4,
                 (rt'3,
                  (rt'2,
                   (rt'1,
                    (rt'0,
                     (rd'4,
                      (rd'3,
                       (rd'2,
                        (rd'1,
                         (rd'0,
                          (false,
                           (false,
                            (false,
                             (false,
                              (false,
                               (false,(false,(false,(false,(true,false))))))))))))))))))))))))))))))) =>
      MultDiv
        (MUL(BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5),
             (BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5),
              BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5))))
   | (function'5,
      (function'4,
       (function'3,
        (function'2,
         (function'1,
          (function'0,
           (rs'4,
            (rs'3,
             (rs'2,
              (rs'1,
               (rs'0,
                (rt'4,
                 (rt'3,
                  (rt'2,
                   (rt'1,
                    (rt'0,
                     (immediate'15,
                      (immediate'14,
                       (immediate'13,
                        (immediate'12,
                         (immediate'11,
                          (immediate'10,
                           (immediate'9,
                            (immediate'8,
                             (immediate'7,
                              (immediate'6,
                               (immediate'5,
                                (immediate'4,
                                 (immediate'3,
                                  (immediate'2,(immediate'1,immediate'0))))))))))))))))))))))))))))))) =>
      let
        val immediate =
          BitsN.fromBitstring
            ([immediate'15,immediate'14,immediate'13,immediate'12,
              immediate'11,immediate'10,immediate'9,immediate'8,
              immediate'7,immediate'6,immediate'5,immediate'4,immediate'3,
              immediate'2,immediate'1,immediate'0],16)
        val rt = BitsN.fromBitstring([rt'4,rt'3,rt'2,rt'1,rt'0],5)
        val rs = BitsN.fromBitstring([rs'4,rs'3,rs'2,rs'1,rs'0],5)
      in
        case boolify'6
          (BitsN.fromBitstring
             ([function'5,function'4,function'3,function'2,function'1,
               function'0],6)) of
           (false,(false,(false,(true,(false,false))))) =>
              Branch(BEQ(rs,(rt,immediate)))
         | (false,(false,(false,(true,(false,true))))) =>
              Branch(BNE(rs,(rt,immediate)))
         | (false,(false,(true,(false,(false,false))))) =>
              ArithI(ADDI(rs,(rt,immediate)))
         | (false,(false,(true,(false,(false,true))))) =>
              ArithI(ADDIU(rs,(rt,immediate)))
         | (false,(false,(true,(false,(true,false))))) =>
              ArithI(SLTI(rs,(rt,immediate)))
         | (false,(false,(true,(false,(true,true))))) =>
              ArithI(SLTIU(rs,(rt,immediate)))
         | (false,(false,(true,(true,(false,false))))) =>
              ArithI(ANDI(rs,(rt,immediate)))
         | (false,(false,(true,(true,(false,true))))) =>
              ArithI(ORI(rs,(rt,immediate)))
         | (false,(false,(true,(true,(true,false))))) =>
              ArithI(XORI(rs,(rt,immediate)))
         | (false,(true,(false,(true,(false,false))))) =>
              Branch(BEQL(rs,(rt,immediate)))
         | (false,(true,(false,(true,(false,true))))) =>
              Branch(BNEL(rs,(rt,immediate)))
         | (false,(true,(true,(false,(false,false))))) =>
              ArithI(DADDI(rs,(rt,immediate)))
         | (false,(true,(true,(false,(false,true))))) =>
              ArithI(DADDIU(rs,(rt,immediate)))
         | (false,(true,(true,(false,(true,false))))) =>
              Load(LDL(rs,(rt,immediate)))
         | (false,(true,(true,(false,(true,true))))) =>
              Load(LDR(rs,(rt,immediate)))
         | (true,(false,(false,(false,(false,false))))) =>
              Load(LB(rs,(rt,immediate)))
         | (true,(false,(false,(false,(false,true))))) =>
              Load(LH(rs,(rt,immediate)))
         | (true,(false,(false,(false,(true,false))))) =>
              Load(LWL(rs,(rt,immediate)))
         | (true,(false,(false,(false,(true,true))))) =>
              Load(LW(rs,(rt,immediate)))
         | (true,(false,(false,(true,(false,false))))) =>
              Load(LBU(rs,(rt,immediate)))
         | (true,(false,(false,(true,(false,true))))) =>
              Load(LHU(rs,(rt,immediate)))
         | (true,(false,(false,(true,(true,false))))) =>
              Load(LWR(rs,(rt,immediate)))
         | (true,(false,(false,(true,(true,true))))) =>
              Load(LWU(rs,(rt,immediate)))
         | (true,(false,(true,(false,(false,false))))) =>
              Store(SB(rs,(rt,immediate)))
         | (true,(false,(true,(false,(false,true))))) =>
              Store(SH(rs,(rt,immediate)))
         | (true,(false,(true,(false,(true,false))))) =>
              Store(SWL(rs,(rt,immediate)))
         | (true,(false,(true,(false,(true,true))))) =>
              Store(SW(rs,(rt,immediate)))
         | (true,(false,(true,(true,(false,false))))) =>
              Store(SDL(rs,(rt,immediate)))
         | (true,(false,(true,(true,(false,true))))) =>
              Store(SDR(rs,(rt,immediate)))
         | (true,(false,(true,(true,(true,false))))) =>
              Store(SWR(rs,(rt,immediate)))
         | (true,(true,(false,(false,(false,false))))) =>
              Load(LL(rs,(rt,immediate)))
         | (true,(true,(false,(true,(false,false))))) =>
              Load(LLD(rs,(rt,immediate)))
         | (true,(true,(false,(true,(true,true))))) =>
              Load(LD(rs,(rt,immediate)))
         | (true,(true,(true,(false,(false,false))))) =>
              Store(SC(rs,(rt,immediate)))
         | (true,(true,(true,(true,(false,false))))) =>
              Store(SCD(rs,(rt,immediate)))
         | (true,(true,(true,(true,(true,true))))) =>
              Store(SD(rs,(rt,immediate)))
         | (_,(_,(_,(_,(_,_))))) => ReservedInstruction
      end;

fun Next () =
  ( case Fetch () of
       Option.SOME w => ( exceptionSignalled := false; Run(Decode w) )
     | NONE => SignalException AdEL
  ; if not (!exceptionSignalled)
      then case ((!BranchDelay),(!BranchTo)) of
              (NONE,NONE) => PC := (BitsN.+((!PC),BitsN.B(0x4,64)))
            | (Option.SOME addr,NONE) =>
               ( BranchDelay := NONE; PC := addr )
            | (NONE,Option.SOME addr) =>
               ( BranchDelay := (Option.SOME addr)
               ; BranchTo := NONE
               ; PC := (BitsN.+((!PC),BitsN.B(0x4,64)))
               )
            | _ => raise UNPREDICTABLE ("Branch follows branch")
    else ()
  ; CP0 :=
    (CP0_Count_rupd((!CP0),BitsN.+((#Count) (!CP0),BitsN.B(0x1,32))))
  );

fun cpr r =
  ("c0_")
    ^
    (case r of
      BitsN.B(0x0,5) => "index"
    | BitsN.B(0x1,5) => "random"
    | BitsN.B(0x2,5) => "entrylo0"
    | BitsN.B(0x3,5) => "entrylo1"
    | BitsN.B(0x4,5) => "context"
    | BitsN.B(0x5,5) => "pagemask"
    | BitsN.B(0x6,5) => "wired"
    | BitsN.B(0x7,5) => "hwrena"
    | BitsN.B(0x8,5) => "badvaddr"
    | BitsN.B(0x9,5) => "count"
    | BitsN.B(0xA,5) => "entryhi"
    | BitsN.B(0xB,5) => "compare"
    | BitsN.B(0xC,5) => "status"
    | BitsN.B(0xD,5) => "cause"
    | BitsN.B(0xE,5) => "epc"
    | BitsN.B(0xF,5) => "prid"
    | BitsN.B(0x10,5) => "config"
    | BitsN.B(0x11,5) => "lladdr"
    | BitsN.B(0x12,5) => "watchlo"
    | BitsN.B(0x13,5) => "watchhi"
    | BitsN.B(0x14,5) => "xcontext"
    | BitsN.B(0x15,5) => "21"
    | BitsN.B(0x16,5) => "22"
    | BitsN.B(0x17,5) => "debug"
    | BitsN.B(0x18,5) => "depc"
    | BitsN.B(0x19,5) => "perfcnt"
    | BitsN.B(0x1A,5) => "errctl"
    | BitsN.B(0x1B,5) => "cacheerr"
    | BitsN.B(0x1C,5) => "taglo"
    | BitsN.B(0x1D,5) => "taghi"
    | BitsN.B(0x1E,5) => "errorepc"
    | BitsN.B(0x1F,5) => "kscratch"
    | _ => raise General.Bind);

fun r n = ("$") ^ (Nat.toString(BitsN.toNat n));

fun c n = (", ") ^ (r n);

fun i N n =
  String.concat
    [", ",if BitsN.<+(n,BitsN.B(0xA,N)) then "" else "0x",
     BitsN.toHexString n];

fun oi N n = if n = (BitsN.B(0x0,N)) then "" else i N n;

fun op1i N (s,n) =
  String.concat[L3.padRightString(#" ",(8,s)),"0x",BitsN.toHexString n];

fun op1r (s,n) = (L3.padRightString(#" ",(8,s))) ^ (r n);

fun op1ri N (s,(r1,n)) = (op1r(s,r1)) ^ (i N n);

fun op2r (s,(r1,r2)) = (op1r(s,r1)) ^ (c r2);

fun op2ri N (s,(r1,(r2,n))) = (op2r(s,(r1,r2))) ^ (i N n);

fun op3r (s,(r1,(r2,r3))) = (op2r(s,(r1,r2))) ^ (c r3);

fun op2roi N (s,(r1,(r2,n))) =
  String.concat[op1r(s,r1),", ",cpr r2,oi N n];

fun opmem N (s,(r1,(r2,n))) =
  String.concat[op1ri N (s,(r1,n)),"(",r r2,")"];

fun instructionToString i =
  case i of
     Shift(SLL(BitsN.B(0x0,5),(BitsN.B(0x0,5),BitsN.B(0x0,5)))) => "nop"
   | Shift(SLL(BitsN.B(0x0,5),(BitsN.B(0x0,5),BitsN.B(0x1,5)))) => "ssnop"
   | Shift(SLL(rt,(rd,imm5))) => op2ri 5 ("sll",(rd,(rt,imm5)))
   | Shift(SRL(rt,(rd,imm5))) => op2ri 5 ("srl",(rd,(rt,imm5)))
   | Shift(SRA(rt,(rd,imm5))) => op2ri 5 ("sra",(rd,(rt,imm5)))
   | Shift(SLLV(rs,(rt,rd))) => op3r("sllv",(rd,(rt,rs)))
   | Shift(SRLV(rs,(rt,rd))) => op3r("srlv",(rd,(rt,rs)))
   | Shift(SRAV(rs,(rt,rd))) => op3r("slav",(rd,(rt,rs)))
   | Branch(JR rs) => op1r("jr",rs)
   | Branch(JALR(rs,rd)) => op2r("jalr",(rd,rs))
   | SYSCALL => "syscall"
   | BREAK => "break"
   | SYNC imm5 => ("sync ") ^ (BitsN.toHexString imm5)
   | MultDiv(MFHI rd) => op1r("mfhi",rd)
   | MultDiv(MTHI rd) => op1r("mthi",rd)
   | MultDiv(MFLO rs) => op1r("mfhi",rs)
   | MultDiv(MTLO rs) => op1r("mtlo",rs)
   | Shift(DSLLV(rs,(rt,rd))) => op3r("dsllv",(rd,(rt,rs)))
   | Shift(DSRLV(rs,(rt,rd))) => op3r("dsrlv",(rd,(rt,rs)))
   | Shift(DSRAV(rs,(rt,rd))) => op3r("dsrav",(rd,(rt,rs)))
   | MultDiv(MADD(rs,rt)) => op2r("madd",(rs,rt))
   | MultDiv(MADDU(rs,rt)) => op2r("maddu",(rs,rt))
   | MultDiv(MSUB(rs,rt)) => op2r("msub",(rs,rt))
   | MultDiv(MSUBU(rs,rt)) => op2r("msubu",(rs,rt))
   | MultDiv(MUL(rs,(rt,rd))) => op3r("mul",(rd,(rs,rt)))
   | MultDiv(MULT(rs,rt)) => op2r("mult",(rs,rt))
   | MultDiv(MULTU(rs,rt)) => op2r("multu",(rs,rt))
   | MultDiv(DIV(rs,rt)) => op2r("div",(rs,rt))
   | MultDiv(DIVU(rs,rt)) => op2r("divu",(rs,rt))
   | MultDiv(DMULT(rs,rt)) => op2r("dmult",(rs,rt))
   | MultDiv(DMULTU(rs,rt)) => op2r("dmultu",(rs,rt))
   | MultDiv(DDIV(rs,rt)) => op2r("ddiv",(rs,rt))
   | MultDiv(DDIVU(rs,rt)) => op2r("ddivu",(rs,rt))
   | ArithR(MOVN(rs,(rt,rd))) => op3r("movn",(rd,(rs,rt)))
   | ArithR(MOVZ(rs,(rt,rd))) => op3r("movz",(rd,(rs,rt)))
   | ArithR(ADD(rs,(rt,rd))) => op3r("add",(rd,(rs,rt)))
   | ArithR(ADDU(rs,(rt,rd))) => op3r("addu",(rd,(rs,rt)))
   | ArithR(SUB(rs,(rt,rd))) => op3r("sub",(rd,(rs,rt)))
   | ArithR(SUBU(rs,(rt,rd))) => op3r("subu",(rd,(rs,rt)))
   | ArithR(AND(rs,(rt,rd))) => op3r("and",(rd,(rs,rt)))
   | ArithR(OR(rs,(rt,rd))) => op3r("or",(rd,(rs,rt)))
   | ArithR(XOR(rs,(rt,rd))) => op3r("xor",(rd,(rs,rt)))
   | ArithR(NOR(rs,(rt,rd))) => op3r("nor",(rd,(rs,rt)))
   | ArithR(SLT(rs,(rt,rd))) => op3r("slt",(rd,(rs,rt)))
   | ArithR(SLTU(rs,(rt,rd))) => op3r("sltu",(rd,(rs,rt)))
   | ArithR(DADD(rs,(rt,rd))) => op3r("dadd",(rd,(rs,rt)))
   | ArithR(DADDU(rs,(rt,rd))) => op3r("daddu",(rd,(rs,rt)))
   | ArithR(DSUB(rs,(rt,rd))) => op3r("dsub",(rd,(rs,rt)))
   | ArithR(DSUBU(rs,(rt,rd))) => op3r("dsubu",(rd,(rs,rt)))
   | Trap(TGE(rs,rt)) => op2r("tge",(rs,rt))
   | Trap(TGEU(rs,rt)) => op2r("tgeu",(rs,rt))
   | Trap(TLT(rs,rt)) => op2r("tlt",(rs,rt))
   | Trap(TLTU(rs,rt)) => op2r("tltu",(rs,rt))
   | Trap(TEQ(rs,rt)) => op2r("teq",(rs,rt))
   | Trap(TNE(rs,rt)) => op2r("tne",(rs,rt))
   | Shift(DSLL(rt,(rd,imm5))) => op2ri 5 ("dsll",(rd,(rt,imm5)))
   | Shift(DSRL(rt,(rd,imm5))) => op2ri 5 ("dsrl",(rd,(rt,imm5)))
   | Shift(DSRA(rt,(rd,imm5))) => op2ri 5 ("dsra",(rd,(rt,imm5)))
   | Shift(DSLL32(rt,(rd,imm5))) => op2ri 5 ("dsll32",(rd,(rt,imm5)))
   | Shift(DSRL32(rt,(rd,imm5))) => op2ri 5 ("dsrl32",(rd,(rt,imm5)))
   | Shift(DSRA32(rt,(rd,imm5))) => op2ri 5 ("dsra32",(rd,(rt,imm5)))
   | Branch(BLTZ(rs,imm)) => op1ri 16 ("bltz",(rs,imm))
   | Branch(BGEZ(rs,imm)) => op1ri 16 ("bgez",(rs,imm))
   | Branch(BLTZL(rs,imm)) => op1ri 16 ("bltzl",(rs,imm))
   | Branch(BGEZL(rs,imm)) => op1ri 16 ("bgezl",(rs,imm))
   | Trap(TGEI(rs,imm)) => op1ri 16 ("tgei",(rs,imm))
   | Trap(TGEIU(rs,imm)) => op1ri 16 ("tgeiu",(rs,imm))
   | Trap(TLTI(rs,imm)) => op1ri 16 ("tlti",(rs,imm))
   | Trap(TLTIU(rs,imm)) => op1ri 16 ("tltiu",(rs,imm))
   | Trap(TEQI(rs,imm)) => op1ri 16 ("teqi",(rs,imm))
   | Trap(TNEI(rs,imm)) => op1ri 16 ("tnei",(rs,imm))
   | Branch(BLTZAL(rs,imm)) => op1ri 16 ("bltzal",(rs,imm))
   | Branch(BGEZAL(rs,imm)) => op1ri 16 ("bgezal",(rs,imm))
   | Branch(BLTZALL(rs,imm)) => op1ri 16 ("bltzall",(rs,imm))
   | Branch(BGEZALL(rs,imm)) => op1ri 16 ("bgezall",(rs,imm))
   | Branch(J imm) => op1i 26 ("j",imm)
   | Branch(JAL imm) => op1i 26 ("jal",imm)
   | ERET => "eret"
   | CP(MFC0(rt,(rd,sel))) => op2roi 3 ("mfc0",(rt,(rd,sel)))
   | CP(DMFC0(rt,(rd,sel))) => op2roi 3 ("dmfc0",(rt,(rd,sel)))
   | CP(MTC0(rt,(rd,sel))) => op2roi 3 ("mtc0",(rt,(rd,sel)))
   | CP(DMTC0(rt,(rd,sel))) => op2roi 3 ("dmtc0",(rt,(rd,sel)))
   | Branch(BEQ(BitsN.B(0x0,5),(BitsN.B(0x0,5),imm))) => op1i 16 ("b",imm)
   | Branch(BEQ(rs,(rt,imm))) => op2ri 16 ("beq",(rs,(rt,imm)))
   | Branch(BNE(rs,(rt,imm))) => op2ri 16 ("bne",(rs,(rt,imm)))
   | Branch(BLEZ(rs,imm)) => op1ri 16 ("blez",(rs,imm))
   | Branch(BGTZ(rs,imm)) => op1ri 16 ("bgtz",(rs,imm))
   | ArithI(ADDI(rs,(rt,imm))) => op2ri 16 ("addi",(rt,(rs,imm)))
   | ArithI(ADDIU(rs,(rt,imm))) => op2ri 16 ("addiu",(rt,(rs,imm)))
   | ArithI(SLTI(rs,(rt,imm))) => op2ri 16 ("slti",(rt,(rs,imm)))
   | ArithI(SLTIU(rs,(rt,imm))) => op2ri 16 ("sltiu",(rt,(rs,imm)))
   | ArithI(ANDI(rs,(rt,imm))) => op2ri 16 ("andi",(rt,(rs,imm)))
   | ArithI(ORI(rs,(rt,imm))) => op2ri 16 ("ori",(rt,(rs,imm)))
   | ArithI(XORI(rs,(rt,imm))) => op2ri 16 ("xori",(rt,(rs,imm)))
   | ArithI(LUI(rt,imm)) => op1ri 16 ("lui",(rt,imm))
   | Branch(BEQL(rs,(rt,imm))) => op2ri 16 ("beql",(rs,(rt,imm)))
   | Branch(BNEL(rs,(rt,imm))) => op2ri 16 ("bnel",(rs,(rt,imm)))
   | Branch(BLEZL(rs,imm)) => op1ri 16 ("blezl",(rs,imm))
   | Branch(BGTZL(rs,imm)) => op1ri 16 ("bgtzl",(rs,imm))
   | ArithI(DADDI(rs,(rt,imm))) => op2ri 16 ("daddi",(rt,(rs,imm)))
   | ArithI(DADDIU(rs,(rt,imm))) => op2ri 16 ("daddiu",(rt,(rs,imm)))
   | Load(LDL(rs,(rt,imm))) => opmem 16 ("ldl",(rt,(rs,imm)))
   | Load(LDR(rs,(rt,imm))) => opmem 16 ("ldr",(rt,(rs,imm)))
   | Load(LB(rs,(rt,imm))) => opmem 16 ("lb",(rt,(rs,imm)))
   | Load(LH(rs,(rt,imm))) => opmem 16 ("lh",(rt,(rs,imm)))
   | Load(LWL(rs,(rt,imm))) => opmem 16 ("lwl",(rt,(rs,imm)))
   | Load(LW(rs,(rt,imm))) => opmem 16 ("lw",(rt,(rs,imm)))
   | Load(LBU(rs,(rt,imm))) => opmem 16 ("lbu",(rt,(rs,imm)))
   | Load(LHU(rs,(rt,imm))) => opmem 16 ("lhu",(rt,(rs,imm)))
   | Load(LWR(rs,(rt,imm))) => opmem 16 ("lwr",(rt,(rs,imm)))
   | Load(LWU(rs,(rt,imm))) => opmem 16 ("lwu",(rt,(rs,imm)))
   | Store(SB(rs,(rt,imm))) => opmem 16 ("sb",(rt,(rs,imm)))
   | Store(SH(rs,(rt,imm))) => opmem 16 ("sh",(rt,(rs,imm)))
   | Store(SWL(rs,(rt,imm))) => opmem 16 ("swl",(rt,(rs,imm)))
   | Store(SW(rs,(rt,imm))) => opmem 16 ("sw",(rt,(rs,imm)))
   | Store(SDL(rs,(rt,imm))) => opmem 16 ("sdl",(rt,(rs,imm)))
   | Store(SDR(rs,(rt,imm))) => opmem 16 ("sdr",(rt,(rs,imm)))
   | Store(SWR(rs,(rt,imm))) => opmem 16 ("swr",(rt,(rs,imm)))
   | Load(LL(rs,(rt,imm))) => opmem 16 ("ll",(rt,(rs,imm)))
   | Load(LLD(rs,(rt,imm))) => opmem 16 ("lld",(rt,(rs,imm)))
   | Load(LD(rs,(rt,imm))) => opmem 16 ("ld",(rt,(rs,imm)))
   | Store(SC(rs,(rt,imm))) => opmem 16 ("sc",(rt,(rs,imm)))
   | Store(SCD(rs,(rt,imm))) => opmem 16 ("scd",(rt,(rs,imm)))
   | Store(SD(rs,(rt,imm))) => opmem 16 ("sd",(rt,(rs,imm)))
   | ReservedInstruction => "???";

fun form1 (rs,(rt,(rd,(imm5,function)))) =
  BitsN.concat[BitsN.B(0x0,6),rs,rt,rd,imm5,function];

fun form2 (rs,(function,imm)) =
  BitsN.concat[BitsN.B(0x1,6),rs,function,imm];

fun form3 (function,(rt,(rd,sel))) =
  BitsN.concat[BitsN.B(0x10,6),function,rt,rd,BitsN.B(0x0,8),sel];

fun form4 (function,(rs,(rt,imm))) = BitsN.concat[function,rs,rt,imm];

fun form5 (rs,(rt,(rd,function))) =
  BitsN.concat[BitsN.B(0x1C,6),rs,rt,rd,BitsN.B(0x0,5),function];

fun Encode i =
  case i of
     Shift(SLL(rt,(rd,imm5))) =>
      form1(BitsN.B(0x0,5),(rt,(rd,(imm5,BitsN.B(0x0,6)))))
   | Shift(SRL(rt,(rd,imm5))) =>
      form1(BitsN.B(0x0,5),(rt,(rd,(imm5,BitsN.B(0x2,6)))))
   | Shift(SRA(rt,(rd,imm5))) =>
      form1(BitsN.B(0x0,5),(rt,(rd,(imm5,BitsN.B(0x3,6)))))
   | Shift(SLLV(rs,(rt,rd))) =>
      form1(rs,(rt,(rd,(BitsN.B(0x0,5),BitsN.B(0x4,6)))))
   | Shift(SRLV(rs,(rt,rd))) =>
      form1(rs,(rt,(rd,(BitsN.B(0x0,5),BitsN.B(0x6,6)))))
   | Shift(SRAV(rs,(rt,rd))) =>
      form1(rs,(rt,(rd,(BitsN.B(0x0,5),BitsN.B(0x7,6)))))
   | Branch(JR rs) =>
      form1
        (rs,
         (BitsN.B(0x0,5),(BitsN.B(0x0,5),(BitsN.B(0x0,5),BitsN.B(0x8,6)))))
   | Branch(JALR(rs,rd)) =>
      form1(rs,(BitsN.B(0x0,5),(rd,(BitsN.B(0x0,5),BitsN.B(0x9,6)))))
   | SYSCALL => BitsN.fromNat(BitsN.toNat(BitsN.B(0xC,6)),32)
   | BREAK => BitsN.fromNat(BitsN.toNat(BitsN.B(0xD,6)),32)
   | SYNC imm5 =>
      BitsN.fromNat(BitsN.toNat(BitsN.@@(imm5,BitsN.B(0xF,6))),32)
   | MultDiv(MFHI rd) =>
      form1
        (BitsN.B(0x0,5),
         (BitsN.B(0x0,5),(rd,(BitsN.B(0x0,5),BitsN.B(0x10,6)))))
   | MultDiv(MTHI rd) =>
      form1
        (BitsN.B(0x0,5),
         (BitsN.B(0x0,5),(rd,(BitsN.B(0x0,5),BitsN.B(0x11,6)))))
   | MultDiv(MFLO rs) =>
      form1
        (rs,
         (BitsN.B(0x0,5),(BitsN.B(0x0,5),(BitsN.B(0x0,5),BitsN.B(0x12,6)))))
   | MultDiv(MTLO rs) =>
      form1
        (rs,
         (BitsN.B(0x0,5),(BitsN.B(0x0,5),(BitsN.B(0x0,5),BitsN.B(0x13,6)))))
   | Shift(DSLLV(rs,(rt,rd))) =>
      form1(rs,(rt,(rd,(BitsN.B(0x0,5),BitsN.B(0x14,6)))))
   | Shift(DSRLV(rs,(rt,rd))) =>
      form1(rs,(rt,(rd,(BitsN.B(0x0,5),BitsN.B(0x16,6)))))
   | Shift(DSRAV(rs,(rt,rd))) =>
      form1(rs,(rt,(rd,(BitsN.B(0x0,5),BitsN.B(0x17,6)))))
   | MultDiv(MADD(rs,rt)) =>
      form5(rs,(rt,(BitsN.B(0x0,5),BitsN.B(0x0,6))))
   | MultDiv(MADDU(rs,rt)) =>
      form5(rs,(rt,(BitsN.B(0x0,5),BitsN.B(0x1,6))))
   | MultDiv(MSUB(rs,rt)) =>
      form5(rs,(rt,(BitsN.B(0x0,5),BitsN.B(0x4,6))))
   | MultDiv(MSUBU(rs,rt)) =>
      form5(rs,(rt,(BitsN.B(0x0,5),BitsN.B(0x5,6))))
   | MultDiv(MUL(rs,(rt,rd))) => form5(rs,(rt,(rd,BitsN.B(0x2,6))))
   | MultDiv(MULT(rs,rt)) =>
      form1(rs,(rt,(BitsN.B(0x0,5),(BitsN.B(0x0,5),BitsN.B(0x18,6)))))
   | MultDiv(MULTU(rs,rt)) =>
      form1(rs,(rt,(BitsN.B(0x0,5),(BitsN.B(0x0,5),BitsN.B(0x19,6)))))
   | MultDiv(DIV(rs,rt)) =>
      form1(rs,(rt,(BitsN.B(0x0,5),(BitsN.B(0x0,5),BitsN.B(0x1A,6)))))
   | MultDiv(DIVU(rs,rt)) =>
      form1(rs,(rt,(BitsN.B(0x0,5),(BitsN.B(0x0,5),BitsN.B(0x1B,6)))))
   | MultDiv(DMULT(rs,rt)) =>
      form1(rs,(rt,(BitsN.B(0x0,5),(BitsN.B(0x0,5),BitsN.B(0x1C,6)))))
   | MultDiv(DMULTU(rs,rt)) =>
      form1(rs,(rt,(BitsN.B(0x0,5),(BitsN.B(0x0,5),BitsN.B(0x1D,6)))))
   | MultDiv(DDIV(rs,rt)) =>
      form1(rs,(rt,(BitsN.B(0x0,5),(BitsN.B(0x0,5),BitsN.B(0x1E,6)))))
   | MultDiv(DDIVU(rs,rt)) =>
      form1(rs,(rt,(BitsN.B(0x0,5),(BitsN.B(0x0,5),BitsN.B(0x1F,6)))))
   | ArithR(MOVZ(rs,(rt,rd))) =>
      form1(rs,(rt,(rd,(BitsN.B(0x0,5),BitsN.B(0xA,6)))))
   | ArithR(MOVN(rs,(rt,rd))) =>
      form1(rs,(rt,(rd,(BitsN.B(0x0,5),BitsN.B(0xB,6)))))
   | ArithR(ADD(rs,(rt,rd))) =>
      form1(rs,(rt,(rd,(BitsN.B(0x0,5),BitsN.B(0x20,6)))))
   | ArithR(ADDU(rs,(rt,rd))) =>
      form1(rs,(rt,(rd,(BitsN.B(0x0,5),BitsN.B(0x21,6)))))
   | ArithR(SUB(rs,(rt,rd))) =>
      form1(rs,(rt,(rd,(BitsN.B(0x0,5),BitsN.B(0x22,6)))))
   | ArithR(SUBU(rs,(rt,rd))) =>
      form1(rs,(rt,(rd,(BitsN.B(0x0,5),BitsN.B(0x23,6)))))
   | ArithR(AND(rs,(rt,rd))) =>
      form1(rs,(rt,(rd,(BitsN.B(0x0,5),BitsN.B(0x24,6)))))
   | ArithR(OR(rs,(rt,rd))) =>
      form1(rs,(rt,(rd,(BitsN.B(0x0,5),BitsN.B(0x25,6)))))
   | ArithR(XOR(rs,(rt,rd))) =>
      form1(rs,(rt,(rd,(BitsN.B(0x0,5),BitsN.B(0x26,6)))))
   | ArithR(NOR(rs,(rt,rd))) =>
      form1(rs,(rt,(rd,(BitsN.B(0x0,5),BitsN.B(0x27,6)))))
   | ArithR(SLT(rs,(rt,rd))) =>
      form1(rs,(rt,(rd,(BitsN.B(0x0,5),BitsN.B(0x2A,6)))))
   | ArithR(SLTU(rs,(rt,rd))) =>
      form1(rs,(rt,(rd,(BitsN.B(0x0,5),BitsN.B(0x2B,6)))))
   | ArithR(DADD(rs,(rt,rd))) =>
      form1(rs,(rt,(rd,(BitsN.B(0x0,5),BitsN.B(0x2C,6)))))
   | ArithR(DADDU(rs,(rt,rd))) =>
      form1(rs,(rt,(rd,(BitsN.B(0x0,5),BitsN.B(0x2D,6)))))
   | ArithR(DSUB(rs,(rt,rd))) =>
      form1(rs,(rt,(rd,(BitsN.B(0x0,5),BitsN.B(0x2E,6)))))
   | ArithR(DSUBU(rs,(rt,rd))) =>
      form1(rs,(rt,(rd,(BitsN.B(0x0,5),BitsN.B(0x2F,6)))))
   | Trap(TGE(rs,rt)) =>
      form1(rs,(rt,(BitsN.B(0x0,5),(BitsN.B(0x0,5),BitsN.B(0x30,6)))))
   | Trap(TGEU(rs,rt)) =>
      form1(rs,(rt,(BitsN.B(0x0,5),(BitsN.B(0x0,5),BitsN.B(0x31,6)))))
   | Trap(TLT(rs,rt)) =>
      form1(rs,(rt,(BitsN.B(0x0,5),(BitsN.B(0x0,5),BitsN.B(0x32,6)))))
   | Trap(TLTU(rs,rt)) =>
      form1(rs,(rt,(BitsN.B(0x0,5),(BitsN.B(0x0,5),BitsN.B(0x33,6)))))
   | Trap(TEQ(rs,rt)) =>
      form1(rs,(rt,(BitsN.B(0x0,5),(BitsN.B(0x0,5),BitsN.B(0x34,6)))))
   | Trap(TNE(rs,rt)) =>
      form1(rs,(rt,(BitsN.B(0x0,5),(BitsN.B(0x0,5),BitsN.B(0x36,6)))))
   | Shift(DSLL(rt,(rd,imm5))) =>
      form1(BitsN.B(0x0,5),(rt,(rd,(imm5,BitsN.B(0x38,6)))))
   | Shift(DSRL(rt,(rd,imm5))) =>
      form1(BitsN.B(0x0,5),(rt,(rd,(imm5,BitsN.B(0x3A,6)))))
   | Shift(DSRA(rt,(rd,imm5))) =>
      form1(BitsN.B(0x0,5),(rt,(rd,(imm5,BitsN.B(0x3B,6)))))
   | Shift(DSLL32(rt,(rd,imm5))) =>
      form1(BitsN.B(0x0,5),(rt,(rd,(imm5,BitsN.B(0x3C,6)))))
   | Shift(DSRL32(rt,(rd,imm5))) =>
      form1(BitsN.B(0x0,5),(rt,(rd,(imm5,BitsN.B(0x3E,6)))))
   | Shift(DSRA32(rt,(rd,imm5))) =>
      form1(BitsN.B(0x0,5),(rt,(rd,(imm5,BitsN.B(0x3F,6)))))
   | Branch(BLTZ(rs,imm)) => form2(rs,(BitsN.B(0x0,5),imm))
   | Branch(BGEZ(rs,imm)) => form2(rs,(BitsN.B(0x1,5),imm))
   | Branch(BLTZL(rs,imm)) => form2(rs,(BitsN.B(0x2,5),imm))
   | Branch(BGEZL(rs,imm)) => form2(rs,(BitsN.B(0x3,5),imm))
   | Trap(TGEI(rs,imm)) => form2(rs,(BitsN.B(0x8,5),imm))
   | Trap(TGEIU(rs,imm)) => form2(rs,(BitsN.B(0x9,5),imm))
   | Trap(TLTI(rs,imm)) => form2(rs,(BitsN.B(0xA,5),imm))
   | Trap(TLTIU(rs,imm)) => form2(rs,(BitsN.B(0xB,5),imm))
   | Trap(TEQI(rs,imm)) => form2(rs,(BitsN.B(0xC,5),imm))
   | Trap(TNEI(rs,imm)) => form2(rs,(BitsN.B(0xE,5),imm))
   | Branch(BLTZAL(rs,imm)) => form2(rs,(BitsN.B(0x10,5),imm))
   | Branch(BGEZAL(rs,imm)) => form2(rs,(BitsN.B(0x11,5),imm))
   | Branch(BLTZALL(rs,imm)) => form2(rs,(BitsN.B(0x12,5),imm))
   | Branch(BGEZALL(rs,imm)) => form2(rs,(BitsN.B(0x13,5),imm))
   | Branch(J imm) => BitsN.@@(BitsN.B(0x2,6),imm)
   | Branch(JAL imm) => BitsN.@@(BitsN.B(0x3,6),imm)
   | ERET => BitsN.B(0x42000018,32)
   | CP(MFC0(rt,(rd,sel))) => form3(BitsN.B(0x0,5),(rt,(rd,sel)))
   | CP(DMFC0(rt,(rd,sel))) => form3(BitsN.B(0x1,5),(rt,(rd,sel)))
   | CP(MTC0(rt,(rd,sel))) => form3(BitsN.B(0x4,5),(rt,(rd,sel)))
   | CP(DMTC0(rt,(rd,sel))) => form3(BitsN.B(0x5,5),(rt,(rd,sel)))
   | Branch(BEQ(rs,(rt,imm))) => form4(BitsN.B(0x4,6),(rs,(rt,imm)))
   | Branch(BNE(rs,(rt,imm))) => form4(BitsN.B(0x5,6),(rs,(rt,imm)))
   | Branch(BLEZ(rs,imm)) =>
      form4(BitsN.B(0x6,6),(rs,(BitsN.B(0x0,5),imm)))
   | Branch(BGTZ(rs,imm)) =>
      form4(BitsN.B(0x7,6),(rs,(BitsN.B(0x0,5),imm)))
   | ArithI(ADDI(rs,(rt,imm))) => form4(BitsN.B(0x8,6),(rs,(rt,imm)))
   | ArithI(ADDIU(rs,(rt,imm))) => form4(BitsN.B(0x9,6),(rs,(rt,imm)))
   | ArithI(SLTI(rs,(rt,imm))) => form4(BitsN.B(0xA,6),(rs,(rt,imm)))
   | ArithI(SLTIU(rs,(rt,imm))) => form4(BitsN.B(0xB,6),(rs,(rt,imm)))
   | ArithI(ANDI(rs,(rt,imm))) => form4(BitsN.B(0xC,6),(rs,(rt,imm)))
   | ArithI(ORI(rs,(rt,imm))) => form4(BitsN.B(0xD,6),(rs,(rt,imm)))
   | ArithI(XORI(rs,(rt,imm))) => form4(BitsN.B(0xE,6),(rs,(rt,imm)))
   | ArithI(LUI(rt,imm)) =>
      form4(BitsN.B(0xF,6),(BitsN.B(0x0,5),(rt,imm)))
   | Branch(BEQL(rs,(rt,imm))) => form4(BitsN.B(0x14,6),(rs,(rt,imm)))
   | Branch(BNEL(rs,(rt,imm))) => form4(BitsN.B(0x15,6),(rs,(rt,imm)))
   | Branch(BLEZL(rs,imm)) =>
      form4(BitsN.B(0x16,6),(rs,(BitsN.B(0x0,5),imm)))
   | Branch(BGTZL(rs,imm)) =>
      form4(BitsN.B(0x17,6),(rs,(BitsN.B(0x0,5),imm)))
   | ArithI(DADDI(rs,(rt,imm))) => form4(BitsN.B(0x18,6),(rs,(rt,imm)))
   | ArithI(DADDIU(rs,(rt,imm))) => form4(BitsN.B(0x19,6),(rs,(rt,imm)))
   | Load(LDL(rs,(rt,imm))) => form4(BitsN.B(0x1A,6),(rs,(rt,imm)))
   | Load(LDR(rs,(rt,imm))) => form4(BitsN.B(0x1B,6),(rs,(rt,imm)))
   | Load(LB(rs,(rt,imm))) => form4(BitsN.B(0x20,6),(rs,(rt,imm)))
   | Load(LH(rs,(rt,imm))) => form4(BitsN.B(0x21,6),(rs,(rt,imm)))
   | Load(LWL(rs,(rt,imm))) => form4(BitsN.B(0x22,6),(rs,(rt,imm)))
   | Load(LW(rs,(rt,imm))) => form4(BitsN.B(0x23,6),(rs,(rt,imm)))
   | Load(LBU(rs,(rt,imm))) => form4(BitsN.B(0x24,6),(rs,(rt,imm)))
   | Load(LHU(rs,(rt,imm))) => form4(BitsN.B(0x25,6),(rs,(rt,imm)))
   | Load(LWR(rs,(rt,imm))) => form4(BitsN.B(0x26,6),(rs,(rt,imm)))
   | Load(LWU(rs,(rt,imm))) => form4(BitsN.B(0x27,6),(rs,(rt,imm)))
   | Store(SB(rs,(rt,imm))) => form4(BitsN.B(0x28,6),(rs,(rt,imm)))
   | Store(SH(rs,(rt,imm))) => form4(BitsN.B(0x29,6),(rs,(rt,imm)))
   | Store(SWL(rs,(rt,imm))) => form4(BitsN.B(0x2A,6),(rs,(rt,imm)))
   | Store(SW(rs,(rt,imm))) => form4(BitsN.B(0x2B,6),(rs,(rt,imm)))
   | Store(SDL(rs,(rt,imm))) => form4(BitsN.B(0x2C,6),(rs,(rt,imm)))
   | Store(SDR(rs,(rt,imm))) => form4(BitsN.B(0x2D,6),(rs,(rt,imm)))
   | Store(SWR(rs,(rt,imm))) => form4(BitsN.B(0x2E,6),(rs,(rt,imm)))
   | Load(LL(rs,(rt,imm))) => form4(BitsN.B(0x30,6),(rs,(rt,imm)))
   | Load(LLD(rs,(rt,imm))) => form4(BitsN.B(0x34,6),(rs,(rt,imm)))
   | Load(LD(rs,(rt,imm))) => form4(BitsN.B(0x37,6),(rs,(rt,imm)))
   | Store(SC(rs,(rt,imm))) => form4(BitsN.B(0x38,6),(rs,(rt,imm)))
   | Store(SCD(rs,(rt,imm))) => form4(BitsN.B(0x3C,6),(rs,(rt,imm)))
   | Store(SD(rs,(rt,imm))) => form4(BitsN.B(0x3F,6),(rs,(rt,imm)))
   | ReservedInstruction => BitsN.B(0x0,32);

end